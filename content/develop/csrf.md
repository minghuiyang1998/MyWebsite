---

id: 10038
type: develop
path: /develop/csrf-xss
title: 关于csrf可以联系到多少知识
author: jasmine
digest: 写这个文章的目的就是安全体系这个课的期末定的是这个，也顺便自我梳理一下
image: http://blog.minghuiyang1998.com/csrf-xss.jpg
create_date: Mon May 20 2019 20:20:53 GMT+0800 (CST)
update_date: Mon May 20 2019 20:20:53 GMT+0800 (CST)
timestamp: 1558354853052
reading_time:  MIN READ
tags: [‘web安全’,'csrf','同源政策'，'cookie']
image_height: 4000
image_width: 6000
palette: {"Vibrant":[4,132,188],"DarkVibrant":[4,80,126],"LightVibrant":[121,208,220],"Muted":[132,162,79],"DarkMuted":[45,72,95],"LightMuted":[160,195,202]}
---



> ​	其实期末周已经抽不出身写梳理文章了，但是刚好遇上了安全课的期末作业，也就顺势梳理一下web安全的一些些知识。本来是打算写csrf和xss的，但是好像做完答辩ppt，为了把csrf这个安全问题给我自己讲清楚已经花了五十页😂，于是就把标题改了，之前看过一个美团技术团队关于xss的文章写的很好的[链接](https://mp.weixin.qq.com/s/kWxnYcCTLAQp5CGFrw30mQ)在这里。
>
> （ps：因为没有专门做过相关的工作，这篇文章讲的并不是很深很实践得到的东西，只是把这一个安全问题可以串联起来的知识点顺一顺，比如计算机网络http无状态，登录态维持与cookie，浏览器同源政策, 一般防范csrf的操作，框架提供的防范操作，OAUTH2存在的csrf问题及防范的方式。）



​	由于浏览器的安全策略——同源政策，进行web开发经常会遇到跨域问题，于是就有了常用的几种解决方式服务器转发，CORS，jsonp。而jsonp的这种我认为有一点点hack的方式其实和csrf攻击的原理是一致的，在不违反同源政策的条件下利用请求资源的方式完成了跨域请求资源。那么：



- 到底什么是csrf攻击，原理是什么？
- 如何去防范csrf攻击？
- 还有一个拓展问题：为什么OAUTH2的过程会存在csrf风险？



下面梳理一下

## CSRF攻击的原理

####浏览器同源政策

同源政策是浏览器的一个安全政策

- 目的：是为了防止将用户信息恶意的盗取传输

- 同源含义：域名（IP），协议头， 端口三者相同

- MDN同源政策的内容：

  - 通常允许跨域写操作 ：重定向以及表单提交。
  - 通常允许跨域资源嵌入：\<script>\<link>\<img>\<video>\<iframe>
  - 不允许跨域读操作: ajax

  

​         不允许跨域读操作， 那么就代表了有三种操作会受到同源政策的限制，即不同源网站间的AJAX的请求，网站间的DOM操作，以及两者间的cookie和indexDB之间的访问。即同源政策通过限制你获取当前用户记录在其他源下的cookie等记录在浏览器端的用户数据，以及限制了使用AJAX发送数据到其他的源的方式，以此来保障安全。那么显而易见，csrf利用的是同源政策允许跨域表单提交，以及允许跨域请求资源完成的攻击。



---



🤔（ps：下述的几个个问题涉及到CORS的执行过程，纯属我突然想到验证了一下，严重偏离文章的内容）

Q：那么AJAX发送一个跨域请求这个请求到底会不会发出去呢？

A：会，但在控制台会看到error告诉你需要你提供CORS的头部

![browser](http://blog.minghuiyang1998.com/10531560167595_.pic.jpg)

Q：那么服务器会受到这个请求吗？

A：会

![nginx](http://blog.minghuiyang1998.com/10541560167692_.pic_hd.jpg)



Q：那么接口其实没有做任何处理，请求到底是怎么被禁止的呢？

查了一下浏览器和服务器的合作判定步骤如下：（[参考文章](<https://segmentfault.com/a/1190000003710973>)）

> 1. 浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。
> 2. 服务器解析程序收到浏览器跨域请求后，根据自身配置返回对应文件头。若未配置过任何允许跨域，则文件头里不包含`Access-Control-Allow-origin`字段，若配置过域名，则返回`Access-Control-Allow-origin`+ `对应配置规则里的域名的方式`。
> 3. 浏览器根据接受到的http文件头里的`Access-Control-Allow-origin`字段做匹配，若无该字段，说明不允许跨域；若有该字段，则对字段内容和当前域名做比对，如果同源，则说明可以跨域，浏览器发送该请求；若不同源，则说明该域名不可跨域，不发送请求



---





####跨域请求伪造（CSRF攻击）

含义：在尊重同源政策的条件下，冒充用户的身份实现安全攻击



- **那他是如何冒充了用户的身份的呢？**

  ​	要回答这个问题就要说到web服务是如何记录和识别用户身份的。熟悉计算机网络http协议的应该知道http传输是无状态的，即两个请求之前是完全无联系的，那么网站就会面临如何去识别一个用户的登录态的问题。维持登录态一般的方式就是利用http头部的cookie存储一些信息，然后利用浏览器，访问一个域名下其他页面请求，浏览器会携带当前域下的cookie这一特性，在服务端进行识别。

  ​	cookie存储的用于识别的信息一般也会有两种：一种是类似于JWT的，在用户登录后将用户的信息加密编码将得到的token塞到cookie里，然后验证就是通过解密检查是否存在某个字段，另一种则是使用session，即在服务端去维持一个数据结构，类似于一个key-value map，然后将登录用户都赋予一个sessionId相当于是在记录一次会话，将sessionId塞到cookie里面。

  ​	这两种方式都存在优劣，第一种的最明显的劣势是存放的用户用户信息必须是很简短的，不然过长的cookie会造成过大的头部，还有一个劣势是对于cookie时效的控制不够灵活。而session的缺陷就在于服务器端要维护这么一个巨大的map，如果获取session的服务挂了，如果且没有防护措施，全站都可能不能用，当服务器不止一台的时候还会有数据不同步的问题，那么就还要涉及到解决数据同步的问题。

  ​	**综上所述用户的身份识别就是利用cookie，那么冒充用户身份的方式即利用访问一个域名下其他页面请求，浏览器会携带当前域下的cookie这一特性。**



- **跨域请求伪造实现有几种方式呢？**

  ​	从同源政策看就两种，一是GET请求通过请求资源的方式，二是POST请求通过form表单的形式，即CSRF攻击GET，POST请求，都是可行的，不过…当然没有人会用GET请求做一个写操作，那么GET请求还需要进行csrf攻击防范吗？我认为是需要的，比如，这个请求要返回一些敏感的用户信息，又比如说这是一个内容平台，这个请求涉及内容。

  

##跨域请求伪造的防范

- csrftoken

  ​	对于GET或者POST请求都可以在cookie里面添加一个csrftoken字段，请求时要把token取出放到请求的body里面或者请求的url里，后端进行对比验证，利用只有同源能访问该源下的cookie进行防范，知乎在cookie里面有一个—xsrf的key，我猜测应该用的是这种方式。

  ​	对于表单的提交还可以在服务端直出的页面在中添加一个hidden的input，在直出时就插入csrftoken，同时将csrftoken添加到cookie中，当利用表单自动提交时，后端就可以通过验证body中的csrftoken与cookie中的是否相同来防范csrf攻击时（这也是Rails，Django框架的做法，框架往往只会让开发者选择是否开启csrf的防范，剩下的生成token加密以及加入页面，服务端接收到请求时解密验证都是对开发者无感的）。例子比如说GitHub修改用户信息的表单提交。

  ​	但上述的存在一个问题，csrftoken没有验证其真实性，只是对比了是否相同，那么让csrftoken加强的方式就是使用session，每次请求都为用户重新生成重置cookie，然后更新map里面对应的csrftoken字段的值。

  

- referer check

  ​	referer是HTTP header中的字段, 记录了HTTP请求来源的地址，防范的原理是验证是否同域或者是否是白名单，但是由于referer是可篡改的，这种方式并不牢靠。

  

- 验证码

  ​	还有一种让用户输入验证码的方式，即在关键操作页面加上验证码，后台收到请求后通过判断验证码来防御CSRF。但这种方法对用户不太友好，不能广泛使用，应用的例子比如说知乎绑定用户第三方账号就需要输入验证码，至于为什么绑定第三方账号需要防范CSRF攻击后面会提到

  

（ps: 关于csrftoken的生成：

​	 一般生成的csrftoken都是一个加密字符串，做的十分好的如Rails框架使用 “一次性密钥（one-time pad）”，每以个密钥只用于加密一个文本，然后就会被销毁。Rails就是为每一个新的CSRF token都重新生成一个一次性密钥，然后使用它来对token进行按位异或操作。再将一次性密钥拼接到上一步得到的字符串前面进行混淆，然后使用Base64进行编码，这样就可以把加密好的token返回到页面。既保证了每次打开页面都是不同的csrftoken又保证了cookie里的csrftoken和页面中的是一致的



![github](http://blog.minghuiyang1998.com/WechatIMG1055.png)	



​	一般的以及非页面直出网站都会使用一个由附加信息加盐加密的字符串，再由服务端进行解密验证，去制造不同的csrftoken，降低受到攻击的风险。）



## 拓展问题：为什么第三方登录也会存在csrf风险？

#### OAUTH2

![oauth2](http://blog.minghuiyang1998.com/oauth.png)



OAUTH2一般分为两个过程：

1. 验证用户

2. 验证客户端（即接入第三方登录端）



####存在的问题

用户验证和客户端的验证并不连续（http无状态）

![](http://blog.minghuiyang1998.com/oauth2(2).png)



绑定账号的案例：（假设微信授权登录没有做csrf的防范）[参考文章](<https://www.jianshu.com/p/c7c8f51713b6>)

1. 张三【攻击者】在A网站点击选择微信登录，跳转微信登录页，点击授权，然后截获微信返回的含有Authorization code，参数的http响应

2. 张三精心构建一个web页面，然后放了一个链接会触发A网站去微信换取access_token的请求

3. 李四【受害者】已经登陆了A网站，但没有把自己的账号和其他社交账号绑定起来，然后点击了这个链接，然后A网站就完成了兑换张三的access_token的流程同时绑定了李四的账号

4. 然后张三就可以微信登录A网站上李四的账号胡作非为了

   

   ![](http://blog.minghuiyang1998.com/3.png)



####防范措施

​	带上state参数（相当于一个csrftoken，state参数和与当前想要绑定的用户的身份相关，如果state和当前用户身份不同不予响应

![](http://blog.minghuiyang1998.com/4.png)



## 总结

​	 服务端并不知道请求来自哪里来自谁，只能用获得的信息完成响应，csrf这个安全问题会涉及到用户信息的安全，所以做好csrf攻击防范十分重要！千万不要像同济大学的网站一样既不防范SQL注入又不防范csrf攻击哦：）



（ps：感谢🙏家乐对这篇文章及我期末答辩的提供的支持❤️）

（再补充一个小问题，是助教答辩的时候提问的，jsonp和csrf攻击的原理类似，那么他作为一个跨域请求的解决方法之一，他的应用场景有哪些呢？我答了一下说如果不涉及一些比较敏感的内容，比如要给ELK发送网站的性能数据，就可以用这种方式去发送GET跨域请求。这个问题我以前没特别思考过，还是有一些启发意义的所以记在这里）



