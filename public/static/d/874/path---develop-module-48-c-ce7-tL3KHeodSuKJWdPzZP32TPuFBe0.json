{"data":{"markdownRemark":{"html":"<blockquote>\n<p> \t故事的开始是导师问我认不认识echarts修改样式的customed.js文件开始的12行代码（tips：本文会出现大量代码用以描述我整理我所记录的js module的演化过程），笔记其实已经是很长时间之前的了，所以今天才来整理花了不少时间才看明白= =</p>\n</blockquote>\n<p>👇echarts修改样式的customed.js文件开始的12行代码：</p>\n<pre><code class=\"language-js\">(function(root, factory) {\n  if (typeof define === \"function\" &#x26;&#x26; define.amd) {\n    // AMD. Register as an anonymous module.\n    define([\"exports\", \"echarts\"], factory);\n  } else if (typeof exports === \"object\" &#x26;&#x26; typeof exports.nodeName !== \"string\") {\n    // CommonJS\n    factory(exports, require(\"echarts\"));\n  } else {\n    // Browser globals\n    factory({}, root.echarts);\n  }\n})(this, function(exports, echarts) {\n  var log = function(msg) {\n    if (typeof console !== \"undefined\") {\n      console &#x26;&#x26; console.error &#x26;&#x26; console.error(msg);\n    }\n  };\n  if (!echarts) {\n    log(\"ECharts is not Loaded\");\n    return;\n  }\n  echarts.registerTheme(\"customed\", {\n      // 这里删去了n行 \n  });\n});\n</code></pre>\n<p>​\t在这段代码里面用到了UMD，js代码模块化的方式，使得这段代码既可以用于服务端又可以用于浏览器，同时也避免了污染全局变量。</p>\n<ul>\n<li>先判断是否支持AMD</li>\n<li>再判断是否支持CommonJs</li>\n<li>前两个都不存在公开到全局</li>\n</ul>\n<h1>在js代码里避免污染全局变量的方法</h1>\n<ul>\n<li>\n<p>闭包 + 立即执行</p>\n<pre><code>(function(){  \n    var page\n    function book(){\n      page = page + 1\n    }\n})()\n</code></pre>\n</li>\n<li>\n<p>命名空间（创建一个对象为他添加方法）调用函数或更改变量值，你总是需要通过主对象的名称将整个事物包装在匿名函数中并以这种方式保护范围</p>\n<pre><code>var main = {}\nmain.book = function(){}\nmain.page = 3;\n\nvar main = {\n  book:function(){},\n  \n}\n</code></pre>\n</li>\n</ul>\n<h1>模块化</h1>\n<ul>\n<li>拆分大文件，单文件功能更独立，模块内外分离</li>\n<li>避免变量污染全局，解决命名冲突</li>\n</ul>\n<h1>js模块化解决方案</h1>\n<p>​\t“历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。”  —— <a href=\"https://es6.ruanyifeng.com/#docs/module\">阮一峰ES6入门</a></p>\n<h3>js实现简单的同步异步模块化机制</h3>\n<ul>\n<li>同步</li>\n</ul>\n<pre><code></code></pre>\n<ul>\n<li>异步</li>\n</ul>\n<pre><code></code></pre>\n<h3>常见js模块化方案</h3>\n<ul>\n<li>\n<p>服务端</p>\n<ul>\n<li>nodejs使用CommonJS的解决方案实现模块加载</li>\n</ul>\n</li>\n<li>\n<p>客户端</p>\n<ul>\n<li>模版渲染 —— （将拆分出来的文件使用<script>或<link>标签的形式引入）</li>\n<li>SPA —— 一般使用webpack进行打包（包括组件的引入，文件的引入）</li>\n</ul>\n</li>\n</ul>\n<p>（原理应该是不一样的，使用webpack会只需要请求一次将打包好的js，css文件返回，而使用<script>与<link>则是每个标签都会进行请求）</p>\n<h3>CommonJS AMD UMD</h3>\n<ul>\n<li>commonJS (nodejs)：同步  用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</li>\n<li>AMD（异步）:所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。首先需要引入require.js文件和一个入口文件main.js。main.js中配置<code>require.config()</code>并规定项目中用到的基础模块。</li>\n<li>CMD和sea.js：CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。</li>\n<li>ES6 Module export{} import</li>\n</ul>\n<h3>webpack（现代前端模块打包工具）</h3>\n<p>由于前端页面有着越来越重的交互需求，以Vue，React为代表的组件化的开发方式离不开模块打包工具</p>\n<p>以webpack为例：</p>\n<ul>\n<li>打包工具做了什么？</li>\n<li>为什么spa页面尤其需要打包工具？</li>\n<li>打包工具会带来什么问题？</li>\n<li>webpack与gulp？</li>\n</ul>","frontmatter":{"id":10026,"type":"develop","title":"js模块化","author":"jasmine","digest":"故事的开始是导师问我认不认识echarts修改样式的customed.js文件开始的12行代码...","create_date":"Tue May 03 2019 10:30:48 GMT+0800 (CST)","update_date":"Tue May 03 2019 10:30:48 GMT+0800 (CST)","reading_time":"8 MIN READ","path":"/develop/module","image":"http://blog.minghuiyang1998.com/module.jpg","tags":[],"palette":{"Vibrant":[242,218,43],"DarkVibrant":[114,51,20],"LightVibrant":[251,235,120],"Muted":[144.15999999999997,127.84000000000002,8.840000000000018],"DarkMuted":[130.1641791044776,58.23134328358209,22.835820895522396],"LightMuted":[148.59712230215825,130.98561151079136,4.402877697841739]}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"prev":{"html":"<h2>写在前面</h2>\n<p>​\t“你认为学校学到的专业课知识有用吗？”，我以前从来不认为学校学到的东西有用，计算机组成原理计算机系统结构操作系统都好浪费时间，考试就背背书，但当我逐渐去深入了解一些前端该了解的知识的时候，我觉得还是很有用的，如果你是个计算机或者软件相关专业的学生，你一定要好好学习基础专业课。</p>\n<p>​\t我了解到浏览器工作原理看的是（<a href=\"https://developers.google.com/web/updates/2018/09/inside-browser-part1\">https://developers.google.com/web/updates/2018/09/inside-browser-part1</a>），知乎和掘金上都有相关文章，我写这篇文章的目的是督促我整理一下所学，尝试把我看完这篇文章以后所认识到的浏览器工作原理学校的操作系统课程的进程线程的知识串一下，毕竟知识那么零碎= =，不去复习思考和整合永远都不知道有用。</p>\n<h2>一些概念</h2>\n<p><strong>进程</strong>：</p>\n<ul>\n<li>程序的执行，由程序和数据两部分组成</li>\n<li>资源分配的最小单位，</li>\n<li>可以创建其他进程，所以一个程序可以是多进程的</li>\n</ul>\n<p><strong>线程：</strong></p>\n<ul>\n<li>调度的最小单位，不拥有资源读取所在进程的内存和其他资源</li>\n<li>引入的原因是共享环境，环境切换代价小于进程，线程的出现是为了挖掘进程内部的并发度，提高并发度的好处在于短时间内可以有更多的事情被处理</li>\n</ul>\n<p><strong>CPU调度</strong>：</p>\n<ul>\n<li>调度程序从内存中就绪可执行的进程里选择一个，并分配cpu（进程调度的算法和进程的几个状态这里就不赘述啦）</li>\n</ul>\n<p><strong>GPU：</strong></p>\n<ul>\n<li>多用于图形处理，用于快速渲染与平滑交互</li>\n</ul>\n<p><strong>并发：</strong></p>\n<ul>\n<li>假装并行，当单核cpu运行时一次只能执行一个进程，并发切换一个进程只能执行一小段时间，让用户感觉很多事情在同时进行</li>\n</ul>\n<h2>浏览器的架构</h2>\n<p>​\t浏览器的架构可能是一个具有多个线程的独立进程，或者存在多个进程但是只有部分进程之间会进行 IPC 通信的结构。本文主要讲的是chrome他是多进程架构的。主要的进程有：</p>\n<ul>\n<li>\n<p>browser进程：包含UI线程，Network线程，主要处理浏览器图形界面，和网络访问等，我的理解是是一个控制进程</p>\n</li>\n<li>\n<p>render进程：每开一个tab都是一个新进程，主要处理这个tab的页面渲染</p>\n</li>\n<li>\n<p>GPU进程：绘制进程</p>\n<p>…(其他的待我后面了解一下再写上来，因为不了解还是不要随便说了：)</p>\n</li>\n</ul>\n<p><strong>为什么用多进程架构？</strong>:  概念里面提到进程之间是并发执行的，进程之间是相互独立的，如果某一个tab没有响应，CPU切换到其他进程去执行不会有影响，即一个tab crash了其他还能正常工作。如果采用的是单进程多线程的模式公共的进程出现了问题，所有的页面都会受到影响</p>\n<h2>chrome的一些special的点</h2>\n<ul>\n<li><strong>渲染进程独立</strong>：每个tab和iframe的渲染进程都是独立的，每个进程自己的私有内存空间（不禁联想到微信小程序的架构），所以能打开的tab数量是有限制的，限制会根据设备的内存和 CPU 功率动态调整，但当 Chrome 达到限制时，它会在一个新的进程中打开这个站点。</li>\n<li><strong>服务化</strong>：在强大的硬件上运行的时候，会细化进程，比如可能会把browser进程中的network线程，UI线程，storage线程都拆为单独的进程，从而提高稳定性，如果唯一资源约束的设备上会整合到一个进程中，从而节省内存占用</li>\n</ul>\n<h2>进程间的通信</h2>\n<p>浏览器中的进程通信包括</p>\n<ul>\n<li>network处理render进程的网络请求</li>\n<li>network在请求数据之前查找render的worker进程（service worker），没有缓存才会开始网络请求</li>\n<li>render将raste后的帧传递给GPU进程进行渲染</li>\n<li>......</li>\n</ul>\n<p>进程通信的方式有:</p>\n<ul>\n<li>\n<p>共享存储区（内存的用户区，进程在创建的时候先找到可用内存建立PCB（系统区），再创建其他部分（用户区））</p>\n</li>\n<li>\n<p>管道</p>\n</li>\n<li>\n<p>消息缓冲</p>\n<p>......</p>\n</li>\n</ul>\n<h2>小结</h2>\n<p>​\t虽然不去了解这些东西，还是可以做好开发，毕竟高级的抽象屏蔽了底层的操作，但是去理解一下这些原理的东西，写代码的时候会有更得心应手恍然大悟的感觉不是吗：）</p>","frontmatter":{"path":"/develop/browser-OS"}},"next":{"html":"","frontmatter":{"path":"/develop/html-form"}}}}