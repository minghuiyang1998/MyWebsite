{"data":{"markdownRemark":{"html":"<blockquote>\n<p>最近很着急的把脑子里的东西小结出来，因为最近学校事情比较多，写代码写的比较少。这篇文章同样从一道题出发，这道题来自于我今年参加的一次微信的笔试，但是写的不是太好还花了很多时间，反思了一下不是很难的题目，终归是基础不够好，还要多加学习。这篇文章就从题目出发，反思一下js的异步处理的一些方法。</p>\n</blockquote>\n<h1>题目</h1>\n<p>​\t大概是写一个测试函数，输入是总共执行的次数和每次发送的请求数目和请求url，比如输入3，4就是发送4个请求一共发送3次，然后记录每次请求到获得返回的时间，最后求平均值返回。</p>\n<h1>思考</h1>\n<ol>\n<li>\n<p>js的异步编程有几种解决方案？</p>\n<ul>\n<li>callback</li>\n<li>promise</li>\n<li>await/async</li>\n</ul>\n</li>\n<li>\n<p>这三种方式的区别</p>\n<ul>\n<li>错误捕获的方式</li>\n<li>常用的场景</li>\n</ul>\n</li>\n</ol>\n<p>​\t这道题存在一个串行异步和一个并行异步的，我当时直接就只考虑用promise写，因为日常开发没怎么用过async/await，但是用promise写就会写的很长，因为要处理串行异步就会存在一个递归。async/await虽然是promise的语法糖，但是学习一下就会发现对于题目这种用法async/await明显会更合适。</p>\n<p>​\t</p>\n<ol>\n<li>async/await 与 promise的关系？</li>\n</ol>\n<p>async/await 本质上还是promise，是promise和generator的语法糖（<a href=\"https://es6.ruanyifeng.com/#docs/async\">详情可见阮一峰老师的ES6入门</a>）</p>\n<pre><code class=\"language-js\">async function f3() {\n  /* 1. 这个函数里面的内容会被包成一个promise，\n  相当于在这里面写了一个return new Promise((resolve, reject) => {})，\n  然后这个Promise的里面又有一个Generator函数用于控制函数自动执行，\n  通过递归调用step函数，顺序执行每一行，如果是异步操作就等待resolve再执行下一行*/\n    \n  try {\n  /* 2. await 后面跟着一个promise, 而await下面的部分会被包成Promise.resolve()\n     相当于在这里写了一个 var z = Promise.resolve(data);  z.then((data)=>{\n      // 这里是await后面的代码\n     })\n  */\n    var z = await Promise.resolve(30);\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nf3();\n</code></pre>\n<p><strong>了解了这些以后我重写了一下这道题目的代码</strong> (这里省去了关于计算平均数的代码以便更清晰的展示思路)</p>\n<ol start=\"2\">\n<li>那么这道题用promise + 递归 写就会是下面这个样子（面试的时候我就是这样写的..)</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nfunction send(times, counts, url) {\n    return new Promise((resolve, reject)=>{\n        _sendConcurrentRequest(counts, url).then((data) => {\n            allData.push(data)\n            if (times) {\n                send(times - 1, counts, url) // 递归调用\n            } else {\n                // 计算平均数\n                resolve(avarage)\n            } \n        }).catch(e => reject(e))  \n    })\n}\n\nfunction _sendConcurrentRequest(counts, url) {\n    return new Promise((resolve, reject) => {\n        let tempList = [], _counts = counts\n         while (_counts) {\n            return new Promise((resolve, reject) => {\n                tempList.push(_sendRequest(url))\n                _counts --\n            })\n        }\n        Promise.all(tempList).then((data) => {\n            resolve(data)\n        }).catch(e => reject(e))\n    })\n}\n\n function _sendRequest(url) {\n    return new Promise((resolve, reject) => {\n      let start = Date.now()\n      // 模拟延时\n      setTimeout(() => {\n        let stop = Date.now()\n        resolve(stop - start)\n      }, 2000)\n    })\n  }\n</code></pre>\n<ol start=\"3\">\n<li>改为使用await + 递归</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nasync function send(times, counts, url) {\n    let data = await _sendConcurrentRequest(counts, url)\n    allData.push(data)\n    \n    if (times) {\n         await send(times - 1, counts, url)\n    } else {\n         return avarage\n    }\n}\n\n// 后面的两个函数没有变化仍是用Promise.all处理并行请求\n</code></pre>\n<ol start=\"4\">\n<li>将使用await的情况由递归变为循环，promise无法改写为循环的情况</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nasync function send(times, counts, url) {\n    while(times) {\n         let data = await _sendConcurrentRequest(counts, url)\n         allData.push(data)\n         times--\n    }\n    return avarage\n}\n</code></pre>\n<blockquote>\n<p>然后就会发现最后一种async/await+循环比第一种更便于理解语义清晰了无数倍：）</p>\n</blockquote>\n<h1>总结</h1>\n<p>​\t为了解决callback hell出现了promise，用then使异步任务的执行更清晰明了的。Promise 的存在问题是代码冗余，不管什么操作后任务都得用Promise 起来带上resolve，reject。例如两个串行的异步操作中间必须有一个同步操作，那么为了能够链式回调，中间的同步操作也得用promise包起来，然后才能then链式调用。而且新接入的同学为了把代码看懂需要去找到这个函数声明的地方，原来的语义就不那么直观了。后来​为了解决串行的异步出现async/await，真正使异步操作能够像同步代码一样去写。</p>\n<p>​\t每种方法都有自己的用处，不存在绝对的好与坏，实习之初导师建议我能用callback直接处理就用callback处理，类似于（返回数据处理不复杂的情况下）两个串联的请求也没必要用promise包起来，两个回调嵌套使用就好了，使用promise反而会使的语义很不清晰。</p>\n<p>​\t除此之使用异步编程最应该注意的问题就是为了后期能够快速定位错误，一定要注意异常捕获。</p>","frontmatter":{"id":10035,"type":"develop","title":"从一道题思考promise与awaitasync的使用场景","author":"jasmine","digest":"在两个月之前因为使用await/async的次数真的不多，导致我也没有用心的去理解他和promise的区别，直到我遇到了这道题..我才稍微有了一点点想法","create_date":"Wed May 01 2019 10:57:26 GMT+0800 (CST)","update_date":"Wed May 01 2019 10:57:26 GMT+0800 (CST)","reading_time":"6 MIN READ","path":"/develop/promise-await-async","image":"http://blog.minghuiyang1998.com/promise-await-async.jpg","tags":["async","promise","await","callback"],"palette":{"Vibrant":[114.92957746478872,127.49999999999999,140.0704225352113],"DarkVibrant":[59.76338028169014,66.3,72.83661971830986],"LightVibrant":[182.16338028169014,188.7,195.23661971830987],"Muted":[128,128,121],"DarkMuted":[72,67,62],"LightMuted":[177,184,191]}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"prev":{"html":"<blockquote>\n<p>写在前面：最近慢慢在把实习期间积累的笔记，整理输出。张鑫旭张老师每周都会有个小测帮助我们夯实基础，我从小测中学到很多，这篇文章是关于某次js小测的收获和思考：）。</p>\n<p>⭐️ps: 这篇文章更像是记录，把我零碎的知识串起来的文章，而不是说明原型链原理的文章。</p>\n</blockquote>\n<h1>问题引出的题目</h1>\n<p>实现一个方法，只要内容形态一致就认为数组和对象相等</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let obj1 = {a: [1, '2'], b: 2}\nlet obj2 = {b: 2, a: [1, '2']}\nlet arr1 = [1,2,{a: 1, b:2}, 9]\nlet arr2 = [1,2,{b: 2, a:1}, 9]\nequal(obj1, obj2) //return true\nequal(arr1, arr2) //return true\nequal(obj1, arr1) //return false\n\n// 然后我是这么写的（思路就是，递归+浅拷贝，大可跳过这部分，因为并不是我收获的重点😂）\nfunction equalObject(obj1, obj2) {\n    if (Object.keys(obj1).length != Object.keys(obj2).length) {\n        return false\n    } else {\n        Object.keys(obj1).forEach((key) => {\n            if (obj1[key] !== obj2[key]) {\n                return false\n            }\n        })\n        return true\n    }\n}\n\nfunction equalArray(arr1, arr2) {\n    return JSON.stringify(arr1) === JSON.stringify(arr2)\n}\n\nfunction equal(obj1, obj2) {\n    let typeEnum = {\n        'array': function (obj1, obj2) {\n            if (obj1.length !== obj2.length) {\n                return false\n            } else {\n                for (let i = 0; i &#x3C; obj1.length; i++) {\n                    let func = typeEnum[_detect(obj1[i], obj2[i])]\n                    if (!func(obj1[i], obj2[i])) {\n                        return false\n                    }\n                }\n                return true\n            }\n        },\n        'object': function (obj1, obj2) {\n            if (Object.keys(obj1).length != Object.keys(obj2).length) {\n                return false\n            } else {\n                let keys = Object.keys(obj1)\n                for (let k = 0; k &#x3C; keys.length; k++) {\n                    let key = keys[k]\n                    let func = typeEnum[_detect(obj1[key], obj2[key])]\n                    if (!func(obj1[key], obj2[key])) {\n                        return false\n                    }\n                }\n                return true\n            }\n        },\n        'other': function (obj1, obj2) {\n            return obj1 === obj2\n        }\n    }\n\n    function _detect(obj1, obj2) {\n        if (Array.isArray(obj1) &#x26;&#x26; Array.isArray(obj2)) {\n            return 'array'\n        } else if (typeof obj1 === 'object' &#x26;&#x26; typeof obj2 === 'object') {\n            return 'object'\n        } else {\n            return 'other'\n        }\n    }\n\n    let func = typeEnum[_detect(obj1, obj2)]\n    return func(obj1, obj2)\n}\n</code></pre>\n<p>但是张老师给刚开始帮我看的时候给了我另一个解决方式，思路差不多，但是代码十分精简</p>\n<pre><code class=\"language-js\">    if (!(o1 instanceof Object) || (o2 instanceof Object)) {\n        return false\n    }\n    if (Object.keys(o1).length !== Object.keys(o2).length) {\n        return false\n    }\n    return Object.keys(o1).every(v => {\n        if (o1[v] instanceof Object) {\n             return equal(o1[v], o2[v])\n        } else {\n            return o1[v]  === o2[v]\n        }\n    })\n}\n\n// 用Object.keys()直接处理了array和object两种类型的情况，虽然后来发现这种方法是是有点小问题的没办法处理equal（[1,2], {'0': 1, '1': 2})这种情况，但是我首先没想到那个（...因为基础不牢跑偏了orz），因为我首先想到的是为什么Object.keys（）可以用来同时处理array和object...\n</code></pre>\n<p>A：Object.keys() ,并不是Object.prototype上的方法，而是定义在Object函数上的静态方法</p>\n<h1>JS的原型系统  &#x26;  Object.keys</h1>\n<p>Q：为什么Object.keys（）可以用来同时处理array和object ？</p>\n<p>为了解决这个问题于是我对js的原型系统的相关概念的重新梳理了一下：</p>\n<p>（js基于原型的实现面向对象，注意区别对象，对象的原型，实例）</p>\n<p><img src=\"http://blog.minghuiyang1998.com/objectkeys-prototype_1.jpeg\" alt=\"objectkeys-prototype_1.pic\"></p>\n<h2>JS的原型系统</h2>\n<ul>\n<li>构造函数（串有关普通函数，构造函数，new，this）</li>\n<li>原型 （prototype属性）</li>\n<li>constructor</li>\n<li>__proto__指针</li>\n<li>原型链 （instance原型链的关系）</li>\n<li>静态方法（Object.keys().....)</li>\n</ul>\n<p>（ps：下述的大部分理解来自JStutorial<a href=\"https://javascript.info/\">https://javascript.info/</a>， 很多东西但当时看完题目也做对了觉得自己都懂了，然后遇到问题再重新理解才发现当时肯定是没懂😂）</p>\n<h4>1. 构造函数</h4>\n<ul>\n<li>\n<p>使用new调用普通函数则普通函数就成了构造函数 </p>\n</li>\n<li>\n<p>new关键词做了什么</p>\n<ol>\n<li>创建一个对象 let obj = { }</li>\n<li>obj.__proto__ = 构造函数.prototype</li>\n<li>执行构造函数中的代码</li>\n<li>返回这个对象</li>\n</ol>\n</li>\n<li>\n<p>用new调用构造函数的时候，调用函数的对象，即函数的this值指向的应该是新创建的对象即上面的obj</p>\n</li>\n</ul>\n<h4>2. prototype属性（原型）</h4>\n<p>​\t每个<strong>函数</strong>都有一个prototype属性，指向<strong>函数的原型对象</strong>(这个属性的值是一个对象)</p>\n<h4>3. constructor</h4>\n<p>​\t函数的原型对象都有一个constructor属性指向函数本身，用构造函数创建实例后，实例的__proto__（原型）和只会默认取得构造函数的prototype属性（解决了对象识别的问题，可以通过属性判断实例室友那个构造函数创建的）</p>\n<h4>4.__proto__指针</h4>\n<p>每个实例都有一个__proto__指针指向构造函数的原型对象</p>\n<h4>5.原型链</h4>\n<p>当试图访问实例的一个属性的时候，会沿着原性链层层向上搜索知道找到匹配的属性，否则报错</p>\n<h4>6.静态方法</h4>\n<p>（jstutorial当时讲这个的时候我真的以为我理解了🌚）</p>\n<p>重新补充上面概念的细节：</p>\n<h5>构造函数（这个地方在浏览器里面console.dir看看就会明白许多）</h5>\n<ul>\n<li>\n<p>所有的<strong>函数</strong>包括内置的<strong>Object()，Function()，Array()，还有自建函数function foo(){}</strong>是函数的__proto__都是一个匿名函数，与Object.prototype, Array.prototype…要区分开来</p>\n<ul>\n<li>special：这个<strong>匿名函数</strong>没有prototype属性,有一个constructor属性是Function（不是本身），<em>proto</em>指向Object.prototype</li>\n<li>special：<strong>函数Object（）</strong>的prototype属性指向Object.prototype, prototype包含两个属性constructor指向Object（）本身，<em>proto</em>指向null</li>\n</ul>\n</li>\n<li>其他<strong>函数如Function（），Array（）</strong>的prototype属性指向自己的原型对象，原型对象的constructor指向自己本身，原型对象的<em>proto</em>属性指向Object.prototype（即构造函数的原型对象是由Object生成的，但是看文章开始的图可见构造函数的__proto__(原型）是匿名函数，可见这两个东西是不一样，没有绑定关系的）</li>\n<li>prototype除了有constructor属性和_<strong>proto</strong>属性还有原型里面定义有的这个类型的方法，比如Array的concat，find等等方法</li>\n</ul>\n<h5>当使用class与extends构造对象的时候</h5>\n<ul>\n<li>使用extends关键词的函数的<em>proto</em>不会是匿名函数，是extends的那个Object(<strong>不仅仅是原型继承，原函数也继承</strong>)</li>\n</ul>\n<h2>Object.keys</h2>\n<p>但是打开看Array的__proto__发现并没有Object.keys()，因为这个方法是定义在Object对象上的方法）</p>\n<p><img src=\"http://blog.minghuiyang1998.com/objectkeys-prototype_2.jpeg\" alt=\"objectkeys-prototype_2.pic\"></p>\n<p>Array和Object都可以用来遍历元素是因为，Array可以看作是key是1，2，3..的Object，然后借用了定义在Object上的这个方法来将所有的key值放到了一个数组里返回</p>\n<h1>小结</h1>\n<p>​\t😂思路跑偏了好远，本来只是想知道为什么Object.keys（）可以用来同时处理array和object，不理解的原因归根究底就是没有理解静态方法，把原型链的知识又从头到尾梳理了一遍解决了很多之前含糊不清的点也是巨大的收获吧～：D</p>\n<p>ps：后来还想到了object移除一组值用的是delete key，array删除某个值用的是splice，为什么呢 ？某天再写吧，这太长了...</p>","frontmatter":{"path":"/develop/objectkeys-prototype"}},"next":{"html":"<blockquote>\n<p>​\tcss真的是很有趣和神奇的东西，如果足够熟悉所有的属性和使用场景，而不只是常用的那几个比如张老师，可以用优雅的代码创造很神奇的效果。刚入门如我刚开始学习css的时候，看了两本书《css权威指南》，张老师的《css世界》（这本其实还没看完，其实内容真的很好，但是更多的与实践相关，所以入门读起来可能真的会比较困难）关于样式最开始就是能实现就好，但是发现当页面越来越复杂，内容越来越多的时候样式不断叠加，内容越来越乱很难维护，自己写着写着就想重写全部了😂。这篇文章主要小结一个css小测和一些一段时间以来的小思考。</p>\n</blockquote>\n<h1>题目</h1>\n<p>实现一个类似于微信聊天界面的布局，兼容移动端即可（<a href=\"https://github.com/zhangxinxu/quiz/issues/16\">小测地址</a>）</p>\n<p><img src=\"http://blog.minghuiyang1998.com/css4.png\" alt=\"css4\"></p>\n<h1>思考</h1>\n<p>这个题目的关键点在于了解一下direction这个属性，我还学到了更多的东西，下面是经过我修改的代码：</p>\n<pre><code class=\"language-html\">&#x3C;head>\n  &#x3C;style>\n    body {\n      margin: 0;\n    }\n\n    p {\n      margin: 0;\n    }\n\n    html {\n      font-size: 16px;\n    }\n\n    @media screen and (min-width: 375px) {\n      html {\n        /* iPhone6的375px尺寸作为16px基准，414px正好18px大小, 600 20px */\n        font-size: calc(100% + 2 * (100vw - 375px) / 39);\n        font-size: calc(16px + 2 * (100vw - 375px) / 39);\n      }\n    }\n\n    @media screen and (min-width: 414px) {\n      html {\n        /* 414px-1000px每100像素宽字体增加1px(18px-22px) */\n        font-size: calc(112.5% + 4 * (100vw - 414px) / 586);\n        font-size: calc(18px + 4 * (100vw - 414px) / 586);\n      }\n    }\n\n    @media screen and (min-width: 600px) {\n      html {\n        /* 600px-1000px每100像素宽字体增加1px(20px-24px) */\n        font-size: calc(125% + 4 * (100vw - 600px) / 400);\n        font-size: calc(20px + 4 * (100vw - 600px) / 400);\n      }\n    }\n\n    @media screen and (min-width: 1000px) {\n      html {\n        /* 1000px往后是每100像素0.5px增加 */\n        font-size: calc(137.5% + 6 * (100vw - 1000px) / 1000);\n        font-size: calc(22px + 6 * (100vw - 1000px) / 1000);\n      }\n    }\n\n    .container {\n      padding: 0 1rem;\n    }\n\n    .chat-item {\n      display: flex;\n      padding: 0.625rem 0;\n    }\n\n    .chat-user {\n      color: #808080;\n      font-size: 1rem;\n      margin-bottom: 0.5rem;\n    }\n\n    .chat-name,\n    .chat-time {\n      display: inline-block;\n    }\n\n    .chat-avatar-wrap {\n      display: inline-block;\n    }\n\n    .chat-avatar {\n      border-radius: 50%;\n      width: 3.75rem;\n      height: 3.75rem;\n      margin-inline-end: 0.8rem;\n    }\n\n    .chat-text {\n      border-radius: 0.75rem;\n      position: relative;\n      padding: 0.75rem 0.625rem;\n\n      background-color: #eee;\n      border-color: #eee;\n      color: #3b3f47;\n    }\n\n    .chat-text p {\n      text-align: left;\n    }\n\n    .chat-text::before {\n      content: \"\";\n      display: inline-block;\n      position: absolute;\n      z-index: -1;\n      width: 2rem;\n      height: 1.2rem;\n      top: -0.1rem;\n      margin-inline-start: -3.2rem;\n      border-top-right-radius: 40% 50%;\n      border-top-left-radius: 40% 50%;\n      border-left: 0.6em solid;\n      border-right: 0.6em solid;\n      border-color: inherit;\n    }\n\n    [data-is-self].chat-item {\n      direction: rtl;\n    }\n\n    [data-is-self] .chat-text {\n      background-color: #00beff;\n      border-color: #00beff;\n      color: #ffffff;\n    }\n  &#x3C;/style>\n&#x3C;/head>\n\n&#x3C;body>\n  &#x3C;div class=\"container\">\n    &#x3C;div class=\"chat-item\">\n      &#x3C;div class=\"chat-avatar-wrap\">\n        &#x3C;img class=\"chat-avatar\" src=\"\"/>\n      &#x3C;/div>\n      &#x3C;div class=\"chat-info\">\n        &#x3C;div class=\"chat-user\">\n          &#x3C;span class=\"chat-name\">提案笙&#x3C;/span>\n          &#x3C;span class=\"chat-time\">9月30日 21:47&#x3C;/span>\n        &#x3C;/div>\n        &#x3C;div class=\"chat-text\">\n          &#x3C;p>什么秘密，我觉得你现在跟我说什么都没有意义&#x3C;/p>\n        &#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/div>\n\n    &#x3C;div class=\"chat-item\" data-is-self>\n      &#x3C;div class=\"chat-avatar-wrap\">\n        &#x3C;img class=\"chat-avatar\" src=\"\"/>\n      &#x3C;/div>\n      &#x3C;div class=\"chat-info\">\n        &#x3C;div class=\"chat-user\">\n          &#x3C;span class=\"chat-name\">提案笙&#x3C;/span>\n          &#x3C;span class=\"chat-time\">9月30日 21:47&#x3C;/span>\n        &#x3C;/div>\n        &#x3C;div class=\"chat-text\">\n          &#x3C;p>什么秘密，我觉得你现在跟我说什么都没有意义&#x3C;/p>\n        &#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/div>\n  &#x3C;/div>\n&#x3C;/body>\n</code></pre>\n<p>感受最深的修改在几个地方：</p>\n<ul>\n<li>选择器</li>\n<li>命名</li>\n<li>一些很好用但是不熟悉的属性direction，margin-inline-start， margin-inline-end</li>\n</ul>\n<ol>\n<li>\n<p>选择器</p>\n<p>​\t在此之前我的习惯是用class和id选择器，但是会发现这里用了属性选择器，属性选择器 [data-is-self] .chat-item-info 写定制样式，而不是像我原来写了left，right两个class，或者可能有人会这样写.chat-item-info. right 。使用属性选择器的好处是含义更清晰，写法也更优雅了，靠左和靠右的消息本质上都是消息，所以为了区别样式拆为两个class，并不如只通过属性不同去定制样式更优雅可读性好。</p>\n</li>\n</ol>\n<p>   这里补充提一个我提的问题</p>\n<p>   Q：张老师平时选择器您一般怎么选择使用的呢？</p>\n<p>   A：一般就是class和id加上属性，通常情况下是不推荐使用多个选择器互相选择的，性能不是关键问题只要不是用了很多的选择器，在为DOMtree匹配样式的时候，选择器过多这个造成性能问题都可以忽略不计，关键是css的特殊性计算规则和层叠规则，会让选择器过多的样式很难被覆盖，然后代码就会越写越乱（原话可能不是这样的，我是根据我的理解回答的，最终解释权归张老师😂）</p>\n<ol start=\"2\">\n<li>\n<p>命名</p>\n<p>​\t当项目很大时，我会为样式命名混乱头疼，还会为样式互相覆盖没有章法越写越乱越写越多而头疼，下面的几种方式是我使用过的几种方式，在这里小结一下他们的区别与用法。</p>\n</li>\n</ol>\n<p>   <strong>命名空间：</strong></p>\n<p>   ​\t最简单的避免样式覆盖和令代码清晰易懂的命名class，用短横线加上一个命名空间比如上面的chat</p>\n<p>   优点：</p>\n<p>   缺点：</p>\n<p>   <strong>css模块化 与 scss ：</strong></p>\n<p>   ​\t使用scss最常用的功能之一，应该有嵌套写法，这种写法会让样式的层叠关系比较清晰，但是这也会造成一个问题，就是嵌套层数多了以后，相当于选择器层级变多了，虽然可以防止样式被污染或污染到其他的样式，但是想要在@media或者一些操作下去覆盖之前的样式也会更难</p>\n<p>   优点：</p>\n<p>   缺点：</p>\n<p>   <strong>Atomic CSS：</strong></p>\n<p>   ​\t首先推荐一下atomic css（可以看看material UI和Github的primer然后你就懂什么是atomic css了）使用它有很多好处，不用担心命名，样式是收敛的十分好管理，打开控制台会发现使用atomic不用去选中元素看样式，所有的class一目了然，变化也一目了然。但是atomic css通常会受到inline style反对者的抨击，觉得这和把样式写在标签上没有区别，说的不是没有道理，但是我认为还是有区别的。</p>\n<p>   ​\t使用atomic我认为应该不是说要严格的完全的使用，像GitHub也是存在部分的定制样式的，只是重复率非常高的比如只是想让父元素display：flex，你可以直接通过给父元素添加叫flex的class而不是在绞尽脑汁为这个节点取一个例如xxx-wrap，然后在css文件中写display，或者妥协的写一个丑陋的inline style然后debug的时候完全忘了这个inline style。我的想法是这是一种inline和独立样式的折中吧（好像扯远了，不过你用一次应该就会上瘾了，因为可以把注意力更多的放在编码上：）。不过团队自己实现一套好用的atomic的样式并不容易，因为团队里面每个人的习惯都不一样，如何符合大家的使用习惯，最大程度的兼容所有的项目和设计师的设计，而不是每写一个都去查文档找命名就十分重要了。atomic的用法最适合用于组件化的开发，如果单独为组件定制样式，修改的时候很容易牵一发而动全身。</p>\n<p>   优点：</p>\n<p>   缺点：</p>\n<ol start=\"3\">\n<li>\n<p>direction这个属性</p>\n<p>​\t这个属性兼容挺好的（详情可以参考张老师的博客）最后提一下的原因是，写的时候会发现不了解direction属性其实很难在左右两边两种消息形式使用同一模块顺序（仔细观察时间和用户名的顺序就会发现也是反的），那么用这个这属性就可以在保持模块顺序，减少定制化的代码</p>\n</li>\n</ol>\n<h1>其他</h1>\n<p>这是一些我认为的让css更好控制更具有全局或局部感的好用法</p>\n<ul>\n<li>\n<p>css变量与css函数</p>\n<p>不需要预编译就可以使用变量，用于控制值相同的属性变化或一次性修改这些属性的值</p>\n</li>\n<li>\n<p>currentColor</p>\n<p>让图标与文字保持相同的颜色</p>\n</li>\n<li>\n<p>rem，em， ch， vh，vm， %多种单位的根据场景不同的使用</p>\n<p>比如移动端rem会让字体间距自适应就类似于小程序中的rpx，ch，em会用在需要等宽字体的情况比如倒计时...</p>\n</li>\n</ul>\n<h1>总结</h1>\n<p>​\t做项目的时候虽然表面上功能效果实现就好，但是当我要去封装个组件或者去思考布局和样式如何安排的时候我会思考很久，因为不熟悉上述提到的一些概念用法还有一些我尚未学习到的概念用法，所以今天整理出来，后面也会多思考来完善直到自己有一套自己认可的熟悉的布局和书写样式的方法</p>","frontmatter":{"path":"/develop/something-about-css"}}}}