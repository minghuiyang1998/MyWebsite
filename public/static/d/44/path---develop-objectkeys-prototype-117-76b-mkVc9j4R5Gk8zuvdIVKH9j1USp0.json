{"data":{"markdownRemark":{"html":"<blockquote>\n<p>写在前面：最近慢慢在把实习期间积累的笔记，整理输出。张鑫旭张老师每周都会有个小测帮助我们夯实基础，我从小测中学到很多，这篇文章是关于某次js小测的收获和思考：）。</p>\n<p>⭐️ps: 这篇文章更像是记录，把我零碎的知识串起来的文章，而不是说明原型链原理的文章。</p>\n</blockquote>\n<h1>问题引出的题目</h1>\n<p>实现一个方法，只要内容形态一致就认为数组和对象相等</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let obj1 = {a: [1, '2'], b: 2}\nlet obj2 = {b: 2, a: [1, '2']}\nlet arr1 = [1,2,{a: 1, b:2}, 9]\nlet arr2 = [1,2,{b: 2, a:1}, 9]\nequal(obj1, obj2) //return true\nequal(arr1, arr2) //return true\nequal(obj1, arr1) //return false\n\n// 然后我是这么写的（思路就是，递归+浅拷贝，大可跳过这部分，因为并不是我收获的重点😂）\nfunction equalObject(obj1, obj2) {\n    if (Object.keys(obj1).length != Object.keys(obj2).length) {\n        return false\n    } else {\n        Object.keys(obj1).forEach((key) => {\n            if (obj1[key] !== obj2[key]) {\n                return false\n            }\n        })\n        return true\n    }\n}\n\nfunction equalArray(arr1, arr2) {\n    return JSON.stringify(arr1) === JSON.stringify(arr2)\n}\n\nfunction equal(obj1, obj2) {\n    let typeEnum = {\n        'array': function (obj1, obj2) {\n            if (obj1.length !== obj2.length) {\n                return false\n            } else {\n                for (let i = 0; i &#x3C; obj1.length; i++) {\n                    let func = typeEnum[_detect(obj1[i], obj2[i])]\n                    if (!func(obj1[i], obj2[i])) {\n                        return false\n                    }\n                }\n                return true\n            }\n        },\n        'object': function (obj1, obj2) {\n            if (Object.keys(obj1).length != Object.keys(obj2).length) {\n                return false\n            } else {\n                let keys = Object.keys(obj1)\n                for (let k = 0; k &#x3C; keys.length; k++) {\n                    let key = keys[k]\n                    let func = typeEnum[_detect(obj1[key], obj2[key])]\n                    if (!func(obj1[key], obj2[key])) {\n                        return false\n                    }\n                }\n                return true\n            }\n        },\n        'other': function (obj1, obj2) {\n            return obj1 === obj2\n        }\n    }\n\n    function _detect(obj1, obj2) {\n        if (Array.isArray(obj1) &#x26;&#x26; Array.isArray(obj2)) {\n            return 'array'\n        } else if (typeof obj1 === 'object' &#x26;&#x26; typeof obj2 === 'object') {\n            return 'object'\n        } else {\n            return 'other'\n        }\n    }\n\n    let func = typeEnum[_detect(obj1, obj2)]\n    return func(obj1, obj2)\n}\n</code></pre>\n<p>但是张老师给刚开始帮我看的时候给了我另一个解决方式，思路差不多，但是代码十分精简</p>\n<pre><code class=\"language-js\">    if (!(o1 instanceof Object) || (o2 instanceof Object)) {\n        return false\n    }\n    if (Object.keys(o1).length !== Object.keys(o2).length) {\n        return false\n    }\n    return Object.keys(o1).every(v => {\n        if (o1[v] instanceof Object) {\n             return equal(o1[v], o2[v])\n        } else {\n            return o1[v]  === o2[v]\n        }\n    })\n}\n\n// 用Object.keys()直接处理了array和object两种类型的情况，虽然后来发现这种方法是是有点小问题的没办法处理equal（[1,2], {'0': 1, '1': 2})这种情况，但是我首先没想到那个（...因为基础不牢跑偏了orz），因为我首先想到的是为什么Object.keys（）可以用来同时处理array和object...\n</code></pre>\n<p>A：Object.keys() ,并不是Object.prototype上的方法，而是定义在Object函数上的静态方法</p>\n<h1>JS的原型系统  &#x26;  Object.keys</h1>\n<p>Q：为什么Object.keys（）可以用来同时处理array和object ？</p>\n<p>为了解决这个问题于是我对js的原型系统的相关概念的重新梳理了一下：</p>\n<p>（js基于原型的实现面向对象，注意区别对象，对象的原型，实例）</p>\n<p><img src=\"http://blog.minghuiyang1998.com/objectkeys-prototype_1.jpeg\" alt=\"objectkeys-prototype_1.pic\"></p>\n<h2>JS的原型系统</h2>\n<ul>\n<li>构造函数（串有关普通函数，构造函数，new，this）</li>\n<li>原型 （prototype属性）</li>\n<li>constructor</li>\n<li>__proto__指针</li>\n<li>原型链 （instance原型链的关系）</li>\n<li>静态方法（Object.keys().....)</li>\n</ul>\n<p>（ps：下述的大部分理解来自JStutorial<a href=\"https://javascript.info/\">https://javascript.info/</a>， 很多东西但当时看完题目也做对了觉得自己都懂了，然后遇到问题再重新理解才发现当时肯定是没懂😂）</p>\n<h4>1. 构造函数</h4>\n<ul>\n<li>\n<p>使用new调用普通函数则普通函数就成了构造函数 </p>\n</li>\n<li>\n<p>new关键词做了什么</p>\n<ol>\n<li>创建一个对象 let obj = { }</li>\n<li>obj.__proto__ = 构造函数.prototype</li>\n<li>执行构造函数中的代码</li>\n<li>返回这个对象</li>\n</ol>\n</li>\n<li>\n<p>用new调用构造函数的时候，调用函数的对象，即函数的this值指向的应该是新创建的对象即上面的obj</p>\n</li>\n</ul>\n<h4>2. prototype属性（原型）</h4>\n<p>​\t每个<strong>函数</strong>都有一个prototype属性，指向<strong>函数的原型对象</strong>(这个属性的值是一个对象)</p>\n<h4>3. constructor</h4>\n<p>​\t函数的原型对象都有一个constructor属性指向函数本身，用构造函数创建实例后，实例的__proto__（原型）和只会默认取得构造函数的prototype属性（解决了对象识别的问题，可以通过属性判断实例室友那个构造函数创建的）</p>\n<h4>4.__proto__指针</h4>\n<p>每个实例都有一个__proto__指针指向构造函数的原型对象</p>\n<h4>5.原型链</h4>\n<p>当试图访问实例的一个属性的时候，会沿着原性链层层向上搜索知道找到匹配的属性，否则报错</p>\n<h4>6.静态方法</h4>\n<p>（jstutorial当时讲这个的时候我真的以为我理解了🌚）</p>\n<p>重新补充上面概念的细节：</p>\n<h5>构造函数（这个地方在浏览器里面console.dir看看就会明白许多）</h5>\n<ul>\n<li>\n<p>所有的<strong>函数</strong>包括内置的<strong>Object()，Function()，Array()，还有自建函数function foo(){}</strong>是函数的__proto__都是一个匿名函数，与Object.prototype, Array.prototype…要区分开来</p>\n<ul>\n<li>special：这个<strong>匿名函数</strong>没有prototype属性,有一个constructor属性是Function（不是本身），<em>proto</em>指向Object.prototype</li>\n<li>special：<strong>函数Object（）</strong>的prototype属性指向Object.prototype, prototype包含两个属性constructor指向Object（）本身，<em>proto</em>指向null</li>\n</ul>\n</li>\n<li>其他<strong>函数如Function（），Array（）</strong>的prototype属性指向自己的原型对象，原型对象的constructor指向自己本身，原型对象的<em>proto</em>属性指向Object.prototype（即构造函数的原型对象是由Object生成的，但是看文章开始的图可见构造函数的__proto__(原型）是匿名函数，可见这两个东西是不一样，没有绑定关系的）</li>\n<li>prototype除了有constructor属性和_<strong>proto</strong>属性还有原型里面定义有的这个类型的方法，比如Array的concat，find等等方法</li>\n</ul>\n<h5>当使用class与extends构造对象的时候</h5>\n<ul>\n<li>使用extends关键词的函数的<em>proto</em>不会是匿名函数，是extends的那个Object(<strong>不仅仅是原型继承，原函数也继承</strong>)</li>\n</ul>\n<h2>Object.keys</h2>\n<p>但是打开看Array的__proto__发现并没有Object.keys()，因为这个方法是定义在Object对象上的方法）</p>\n<p><img src=\"http://blog.minghuiyang1998.com/objectkeys-prototype_2.jpeg\" alt=\"objectkeys-prototype_2.pic\"></p>\n<p>Array和Object都可以用来遍历元素是因为，Array可以看作是key是1，2，3..的Object，然后借用了定义在Object上的这个方法来将所有的key值放到了一个数组里返回</p>\n<h1>小结</h1>\n<p>​\t😂思路跑偏了好远，本来只是想知道为什么Object.keys（）可以用来同时处理array和object，不理解的原因归根究底就是没有理解静态方法，把原型链的知识又从头到尾梳理了一遍解决了很多之前含糊不清的点也是巨大的收获吧～：D</p>\n<p>ps：后来还想到了object移除一组值用的是delete key，array删除某个值用的是splice，为什么呢 ？某天再写吧，这太长了...</p>","frontmatter":{"id":10006,"type":"develop","title":"为什么深拷贝不能用Object.keys统一处理Array与object——拓展到static方法原型原型链","author":"jasmine","digest":"这篇文章的起源是写了一个深拷贝的方法，然而老师说我写的太长了，告诉我你可以用Object.keys同时处理Array与Object，但是真的可以这样处理吗？当然不可以因为会漏掉一种情况，但是为什么Array也可以用Object.keys呢，这个方法并不是Object.prototype上的方法...","create_date":"Sun Apr 15 2019 08:53:16 GMT+0800 (CST)","update_date":"Sun Apr 15 2019 08:53:16 GMT+0800 (CST)","reading_time":"3 MIN READ","path":"/develop/objectkeys-prototype","image":"http://blog.minghuiyang1998.com/objectkeys-prototype.jpg","tags":["static methods","prototype"],"palette":{"Vibrant":[130,166,212],"DarkVibrant":[33.9392857142857,62.353571428571406,98.6607142857143],"LightVibrant":[195,219,252],"Muted":[100,124,159],"DarkMuted":[41,65,77],"LightMuted":[188,196,220]}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"prev":{"html":"<blockquote>\n<p>这篇文章小结一下我理解的js是如何工作的？ 目的是把脑子里js引擎执行上下文，调用堆栈，eventloop，作用域作用域链，this的知识串起来（不会讨论service worker相关的内容），学习的时候往上并没有一篇十分完整的文章，所以花了一些时间才串了起来。</p>\n</blockquote>\n<p>简要的思路：</p>\n<ul>\n<li>程序执行方式</li>\n<li>v8引擎</li>\n<li>\n<p>js运行时</p>\n<ul>\n<li>宿主环境</li>\n<li>浏览器</li>\n<li>js运行时</li>\n<li>详细的代码段解析执行的过程</li>\n</ul>\n</li>\n</ul>\n<h1>程序的执行方式</h1>\n<ul>\n<li>解释：如Ruby， Javascript （转化一条执行一条，更灵活）</li>\n<li>编译：如C， C++， Java（全部转化完后执行，更多的优化）</li>\n</ul>\n<p>ps：现在很多语言两种方式都支持，即两种方式的区别是变为可执行机器码的过程有些不同</p>\n<p><strong>JS是解释型的还是编译型的？</strong></p>\n<p>​\t提出这个问题的原因是js存在声明提升，如果他是解释型的应该就不会有声明提升的问题呀。出现声明提升是有解释器的处理方式造成的。</p>\n<p>js的解释过程大致为：</p>\n<ul>\n<li>v8引擎进入作用域，词法分析整个作用域，形成AST，每遇到一个声明分配内存（这就造成了声明提升的现象，如果使用了babel应该就是在这个阶段就是改写生成的AST树变成ES5的语法）</li>\n<li>由AST再编为机器码，执行</li>\n</ul>\n<p>（ps：js的编译机制JIT（即时编译），会优化js代码的执行效率，优化类似于循环语句，还有进行热语句存储）</p>\n<p>​\t总的来说，js是单线程执行的，基于之前浏览器与操作系统那一篇，于chrome浏览器上就是每个tab上的渲染进程上的main线程。与java语言需要编译得到jar包不同的是，js是解释执行的，js引擎每次会解析执行部分代码（相当于是部分编译的）</p>\n<p><strong>JS与Java？</strong></p>\n<table>\n<thead>\n<tr>\n<th>java</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一次编译得到可执行文件（需要编译器和JVM）</td>\n<td>需要运行环境如NodeJS，浏览器（不需要编译器，但是需要宿主环境）</td>\n</tr>\n<tr>\n<td>强类型</td>\n<td>弱类型（动态类型）运行时才知道</td>\n</tr>\n<tr>\n<td>多线程（语言本身支持异步）</td>\n<td>单线程（环境支持异步）</td>\n</tr>\n</tbody>\n</table>\n<h1>v8引擎</h1>\n<ul>\n<li>v8引擎使用c++编写的，同时存在于浏览器和Node环境用于解释执行js代码</li>\n<li>v8旨在提高了js解析性能，使用了两个compiler</li>\n<li>\n<p>内部存在四个线程</p>\n<ul>\n<li>编译执行线程</li>\n<li>辅助编译线程</li>\n<li>检查耗时方法线程</li>\n<li>处理垃圾回收线程</li>\n</ul>\n</li>\n<li>\n<p>组成部分</p>\n<ul>\n<li>内存堆：内存分配 </li>\n<li>调用栈：代码执行</li>\n</ul>\n</li>\n</ul>\n<p>（ps：看过一篇文章讲了建立在理解js代码运行原理上写出优化的代码，写的超级好，分享在<a href=\"https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e\">这里</a>（需要科学上网））</p>\n<p>js是单线程执行的，所以也只有一个调用栈，所以js不存在死锁，但是会存在阻塞，那么如何在不阻塞UI的情况下执行复杂的代码和异步操作呢？</p>\n<p>[<a href=\"https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf\">参考文章</a>]</p>\n<h1>Js运行时</h1>\n<h2>宿主环境</h2>\n<p>​\t如浏览器， Node：Js引擎 + eventloop机制 + API（在浏览器和Node中的event loop机制是不一样的， 浏览器和Node提供的API也是不一样的）</p>\n<h2>浏览器</h2>\n<p>简要画了一下浏览器整个程序的运行过程</p>\n<p><img src=\"http://blog.minghuiyang1998.com/eventloop.png\" alt=\"eventloop\"></p>\n<h3>js运行时基本组成部分</h3>\n<p>浏览器提供webAPI   +    eventloop  +   call back queue</p>\n<ul>\n<li>\n<p>eventloop： js的执行机制用来调度js引擎执行js代码，也使js能实现异步执行。eventloop机制会调用js引擎处理程序中多个块的执行执行调度事件，监控调用栈与call back queue。</p>\n<blockquote>\n<p> 例如：js程序段发送ajax请求有回调，js引擎告诉宿主环境“嘿，我现在要暂停执行了，但你完成请求得到数据记得让我执行回调函数”然后浏览器设置网络响应的监听，当他有东西返回的时候它将会把回调函数插入到事件循环队列然后执行(<a href=\"\">隔得有点久了，找到参考原文会放上来</a>）</p>\n</blockquote>\n</li>\n<li>\n<p>Web API：访问其他的线程的接口，属于浏览器并行启动的其他部分（即在浏览器运行原理和操作系统中提到的其他进程与线程）</p>\n<p>如：DOM， ajax， setTimeout...</p>\n</li>\n<li>\n<p>call back queue：用来存放待执行的回调</p>\n</li>\n</ul>\n<p>例如：执行一个setTimeout(cb, time)</p>\n<ul>\n<li>首先加入call stack（调用栈）执行</li>\n<li>浏览器创建一个定时器（Web API的一部分）开始倒计时</li>\n<li>call stack执行完该代码弹出执行下一句</li>\n<li>定时完成将cb加入call back queue（回调队列）</li>\n<li>当call stack为空从call back queue中取出cs入call stack执行</li>\n</ul>\n<p>（所以setTimeout的定时是加入call back queue的事件而不是执行时间，setTimeout的主要任务也不是用来处理动画，而是拆分耗时操作，动画的操作应该尽可能使用requestAnimationFrame，因为它执行在线程重新渲染画面之前，而使用setTimeout就是每次执行call back queue队列中任务时，这里说的很粗略，推荐看看<a href=\"https://www.youtube.com/watch?v=cCOL7MC4Pl0\">JakeArchibald在Google大会上的演讲</a>理解一下（需要科学上网））</p>\n<p><strong>补充</strong></p>\n<ul>\n<li>\n<p>ES6指定了eventloop如何工作，即技术上应该是属于js引擎的范畴而不再是宿主环境的范畴，愿意是引入了promise</p>\n<ul>\n<li>\n<p>Job Queue（作业队列）</p>\n</li>\n<li>\n<p>eventloop 每执行到调用栈为空称为一个tick（一个eventloop，在Vue中也有$nextTick）</p>\n</li>\n<li>\n<p>作业队列实际跟在事件队列每个tick末尾的一个队列，在执行至call stack为空时，会先去检查job queue是否为空，将job queue执行为空才会去检查call back queue</p>\n</li>\n<li>\n<p>有点像setTimeout（cb，0）的hack，但有个更明确的执行顺序：稍后后执行但是会尽快执行</p>\n</li>\n</ul>\n<p>所以js中关于异步的操作就分为了两类</p>\n<ul>\n<li>setTimeout</li>\n<li>promise</li>\n</ul>\n</li>\n</ul>\n<p><strong>小结</strong>：在详述执行过程前重新理顺上文内容就是，js引擎解析执行js代码，有调用栈内存堆组成，只会在任一时刻执行一个程序，如何去调用js执行你的程序，由周围的宿主环境调度执行</p>\n<p>call stack有三个任务来源</p>\n<ul>\n<li>主任务队列（js文件中的代码，或script标签中的代码）</li>\n<li>Job queue（microtask）</li>\n<li>call back queue</li>\n</ul>\n<h3>js引擎处理一个代码段的详细过程</h3>\n<blockquote>\n<p> 这个过程解释了声明提升，作用域链及this的形成原因</p>\n</blockquote>\n<p>由于解析的方式会提到以下的语言特性</p>\n<ul>\n<li>闭包（closure）：在函数内部可以访问到外部函数（环境）变量的现象</li>\n<li>声明提升（raising）：用var声明在调用处下方的变量仍可访问</li>\n<li>this：调用函数的对象（ps：很多文章会解释为执行上下文，但是我认为不太对）</li>\n<li>作用域（scope）</li>\n<li>作用域链（scope chain）</li>\n</ul>\n<p>当js引擎读入一个代码段</p>\n<p><img src=\"http://blog.minghuiyang1998.com/scope-chain.png\" alt=\"scope-chain\"></p>\n<ul>\n<li>\n<p>这里的读入一个代码段常但不仅仅指的是一个函数的调用, 在ES6中是存在块级作用域的 </p>\n</li>\n<li>\n<p>js是静态作用域（lexical scope，还有一个dynamic scope这个概念在 <em>you don‘t know js</em> 有解释），含义是js的作用范围在编译时被确定，而不是运行时，这促成了js的两个语言特性闭包（closure）以及声明提升（raising）</p>\n</li>\n<li>\n<p>如果函数层层调用，call stack中会一层一层入栈，如果是递归不恰当，就会遇到栈溢出（stack exceeding）的情况。外层环境中的变量能否访问到和外层函数是否仍在call stack中是没有关系的，例如尾递归的调用方式虽然外层函数调用完成出栈了，但是由于保留在函数作用域中的是对变量的索引指向内存中变量存放的位置，所以即使是声明在外层函数中的变量，只要变量的引用不为0，就不会释放内存，所以closure的不恰当使用还会造成内存泄漏的问题（垃圾回收机制是不会回收这部分的内存的）</p>\n</li>\n<li>\n<p>如果是回调函数？为什么回调函数会有this丢失的情况？</p>\n<p>回调函数的声明并不会被分配内存和[[scope]]属性中，而是由web api进行处理，在异步任务结束时将函数的调用放入相应的队列。此时如果不绑定回调函数的调用对象this，那么函数就会遇到访问不到声明处外层对象内部定义的变量。这是由于在函数内部执行函数调用时，都隐式调用了function.call(this)，没有指定调用对象的函数调用，this指向window，那么遇到变量去作用域链上查找的时候window上没有就undefined了</p>\n</li>\n<li>\n<p>作用域链上的查找和原型链上的查找？</p>\n<p>当以objName.xxx方式调用函数时，当前对象的定义中没有该方法时就会到原型链上去查找，而在执行过程中遇到函数的调用，只会到作用域链上去查找</p>\n</li>\n<li>\n<p>可以像下图一样测试</p>\n<p>在控制台中查看call stack，然后在函数调用内部去把这个正在执行的函数console.dir()</p>\n<p><img src=\"http://blog.minghuiyang1998.com/call-stack.png\" alt=\"call stack\"></p>\n</li>\n</ul>\n<h1>总结</h1>\n<p>​\t我还在研究有些部分的正误，因为看到的资料大多对于执行上下文这个部分说的并不是很清楚，对这部分的一直挖掘其实是从很多文章误将this命名为执行上下文让我十分疑惑开始的，我也是慢慢理顺，现在得到的串联应该说是我能暂时能把所有知识接上的串联：）</p>","frontmatter":{"path":"/develop/js-eventloop-engine"}},"next":{"html":"<blockquote>\n<p>最近很着急的把脑子里的东西小结出来，因为最近学校事情比较多，写代码写的比较少。这篇文章同样从一道题出发，这道题来自于我今年参加的一次微信的笔试，但是写的不是太好还花了很多时间，反思了一下不是很难的题目，终归是基础不够好，还要多加学习。这篇文章就从题目出发，反思一下js的异步处理的一些方法。</p>\n</blockquote>\n<h1>题目</h1>\n<p>​\t大概是写一个测试函数，输入是总共执行的次数和每次发送的请求数目和请求url，比如输入3，4就是发送4个请求一共发送3次，然后记录每次请求到获得返回的时间，最后求平均值返回。</p>\n<h1>思考</h1>\n<ol>\n<li>\n<p>js的异步编程有几种解决方案？</p>\n<ul>\n<li>callback</li>\n<li>promise</li>\n<li>await/async</li>\n</ul>\n</li>\n<li>\n<p>这三种方式的区别</p>\n<ul>\n<li>错误捕获的方式</li>\n<li>常用的场景</li>\n</ul>\n</li>\n</ol>\n<p>​\t这道题存在一个串行异步和一个并行异步的，我当时直接就只考虑用promise写，因为日常开发没怎么用过async/await，但是用promise写就会写的很长，因为要处理串行异步就会存在一个递归。async/await虽然是promise的语法糖，但是学习一下就会发现对于题目这种用法async/await明显会更合适。</p>\n<p>​\t</p>\n<ol>\n<li>async/await 与 promise的关系？</li>\n</ol>\n<p>async/await 本质上还是promise，是promise和generator的语法糖（<a href=\"https://es6.ruanyifeng.com/#docs/async\">详情可见阮一峰老师的ES6入门</a>）</p>\n<pre><code class=\"language-js\">async function f3() {\n  /* 1. 这个函数里面的内容会被包成一个promise，\n  相当于在这里面写了一个return new Promise((resolve, reject) => {})，\n  然后这个Promise的里面又有一个Generator函数用于控制函数自动执行，\n  通过递归调用step函数，顺序执行每一行，如果是异步操作就等待resolve再执行下一行*/\n    \n  try {\n  /* 2. await 后面跟着一个promise, 而await下面的部分会被包成Promise.resolve()\n     相当于在这里写了一个 var z = Promise.resolve(data);  z.then((data)=>{\n      // 这里是await后面的代码\n     })\n  */\n    var z = await Promise.resolve(30);\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nf3();\n</code></pre>\n<p><strong>了解了这些以后我重写了一下这道题目的代码</strong> (这里省去了关于计算平均数的代码以便更清晰的展示思路)</p>\n<ol start=\"2\">\n<li>那么这道题用promise + 递归 写就会是下面这个样子（面试的时候我就是这样写的..)</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nfunction send(times, counts, url) {\n    return new Promise((resolve, reject)=>{\n        _sendConcurrentRequest(counts, url).then((data) => {\n            allData.push(data)\n            if (times) {\n                send(times - 1, counts, url) // 递归调用\n            } else {\n                // 计算平均数\n                resolve(avarage)\n            } \n        }).catch(e => reject(e))  \n    })\n}\n\nfunction _sendConcurrentRequest(counts, url) {\n    return new Promise((resolve, reject) => {\n        let tempList = [], _counts = counts\n         while (_counts) {\n            return new Promise((resolve, reject) => {\n                tempList.push(_sendRequest(url))\n                _counts --\n            })\n        }\n        Promise.all(tempList).then((data) => {\n            resolve(data)\n        }).catch(e => reject(e))\n    })\n}\n\n function _sendRequest(url) {\n    return new Promise((resolve, reject) => {\n      let start = Date.now()\n      // 模拟延时\n      setTimeout(() => {\n        let stop = Date.now()\n        resolve(stop - start)\n      }, 2000)\n    })\n  }\n</code></pre>\n<ol start=\"3\">\n<li>改为使用await + 递归</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nasync function send(times, counts, url) {\n    let data = await _sendConcurrentRequest(counts, url)\n    allData.push(data)\n    \n    if (times) {\n         await send(times - 1, counts, url)\n    } else {\n         return avarage\n    }\n}\n\n// 后面的两个函数没有变化仍是用Promise.all处理并行请求\n</code></pre>\n<ol start=\"4\">\n<li>将使用await的情况由递归变为循环，promise无法改写为循环的情况</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nasync function send(times, counts, url) {\n    while(times) {\n         let data = await _sendConcurrentRequest(counts, url)\n         allData.push(data)\n         times--\n    }\n    return avarage\n}\n</code></pre>\n<blockquote>\n<p>然后就会发现最后一种async/await+循环比第一种更便于理解语义清晰了无数倍：）</p>\n</blockquote>\n<h1>总结</h1>\n<p>​\t为了解决callback hell出现了promise，用then使异步任务的执行更清晰明了的。Promise 的存在问题是代码冗余，不管什么操作后任务都得用Promise 起来带上resolve，reject。例如两个串行的异步操作中间必须有一个同步操作，那么为了能够链式回调，中间的同步操作也得用promise包起来，然后才能then链式调用。而且新接入的同学为了把代码看懂需要去找到这个函数声明的地方，原来的语义就不那么直观了。后来​为了解决串行的异步出现async/await，真正使异步操作能够像同步代码一样去写。</p>\n<p>​\t每种方法都有自己的用处，不存在绝对的好与坏，实习之初导师建议我能用callback直接处理就用callback处理，类似于（返回数据处理不复杂的情况下）两个串联的请求也没必要用promise包起来，两个回调嵌套使用就好了，使用promise反而会使的语义很不清晰。</p>\n<p>​\t除此之使用异步编程最应该注意的问题就是为了后期能够快速定位错误，一定要注意异常捕获。</p>","frontmatter":{"path":"/develop/promise-await-async"}}}}