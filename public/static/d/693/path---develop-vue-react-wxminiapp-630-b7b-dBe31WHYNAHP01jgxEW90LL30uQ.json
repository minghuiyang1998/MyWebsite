{"data":{"markdownRemark":{"html":"<blockquote>\n<p>在前端快速发展的这段时间，越来越多的东西如app，桌面应用都可以用接近于前端的开发方式进行开发，这篇文章就是用来记录一下，看完了React的开发文档并使用过react后，结合之前使用过的vue，微信小程序的一些小想法。</p>\n</blockquote>\n<h1>SPA</h1>\n<h3>相似点</h3>\n<ul>\n<li>\n<p>数据驱动的（data变对应使用的地方会自动更新，适用于复杂的状态管理不再需要繁复的DOM操作）</p>\n<ul>\n<li>生命周期</li>\n<li>virtual dom和real dom 和diff 算法</li>\n<li>模版解析——实例化和内容替换涉及到一些写法不同的问题，都是由js渲染的页面</li>\n</ul>\n</li>\n<li>\n<p>组件化（组件也都是对象，无论是vue还是react）</p>\n<ul>\n<li>组件之间的消息传递：父子，子父，页面中的不相关的两个组件</li>\n<li>由基础组装高阶组件</li>\n</ul>\n</li>\n<li>\n<p>打包工具——webpack（避免用多组件的单文件显得很臃肿）</p>\n<ul>\n<li>由webpack完成组装，服务端只提供数据</li>\n</ul>\n</li>\n</ul>\n<h3>不同的体验</h3>\n<ul>\n<li>\n<p>首先写法上的不同是比较明显的，但我感觉都是模版的问题就不在这里纤细分析和列出来了</p>\n</li>\n<li>\n<p>vue有computed和watch和双向绑定v-model，而react需要手动引入mobX（这一点很类似于小程序的开发）</p>\n</li>\n<li>\n<p>react的编程体验更明显，会让我想起类似于于ejs的模版语言，在jsx模版里面可以嵌入任何的表达式，使用js的逻辑相较于vue更强的格式更快的上手比如v-if，v-else，react会更灵活但需要更好的js基础</p>\n</li>\n</ul>\n<h1>微信小程序</h1>\n<p>​\t小程序是没有computed和watched，也没有类似于vuex的多组件的状态管理工具（虽然大部分需求也不需要）。vue和react是前端框架，js运行是单线程的，而小程序是多线程的架构，每个页面一个webview线程再加上一个js线程，虽然分为三个文件js，html，css，但实际上是两个运行时wxs wxml wxss 在一个运行时类比于web的js html css，js是相当于一个控制器，与页面相关的操作要用setData和exec（）的方式，这样架构能够让页面更快加载渲染（具体可以看看小程序官网的生命周期），而之前看过一篇觉得挺好理解受益颇多的文章，了解<a href=\"https://mp.weixin.qq.com/s/X4yAFZBNLwaDUFYaR0Cn5g\">浏览器的加载原理</a>，一个tab的渲染在composite之前都是在渲染进程的main线程上进行的，即生成DOM和解析js是在一个线程上的，所以将script标签插入到其他节点中会阻塞html的解析DOM树的生成</p>\n<p>​\t由于实习的工作，在体验react之前更早接触小程序。最近面试也被问到过为什么做小程序的重构，从mpvue迁回原生，虽然小程序的写法和vue和react有相同之处，但我从上面的小的想法来看觉得是差别挺大的，所以可能vue的开发方式还是不能够完全照搬到小程序开发上来的吧。</p>\n<p>​</p>","frontmatter":{"id":10020,"type":"develop","title":"体验过vue，react，微信小程序后的一些小总结","author":"jasmine","digest":"在使用过vue，react，和微信小程序开发后对于他们的一些异同点一些微小的总结","create_date":"Sat Apr 27 2019 16:31:50 GMT+0800 (CST)","update_date":"Sat Apr 27 2019 16:31:50 GMT+0800 (CST)","reading_time":"6 MIN READ","path":"/develop/vue-react-wxminiapp","image":"http://blog.minghuiyang1998.com/vue-react-wxminiapp.jpg","tags":["wxapp","vue","react"],"palette":{"Vibrant":[198,133,44],"DarkVibrant":[107,63,6],"LightVibrant":[233,229,146],"Muted":[180,136,84],"DarkMuted":[102,75,55],"LightMuted":[148,189,191]}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"prev":{"html":"<blockquote>\n<p>写在前面：最近慢慢在把实习期间积累的笔记，整理输出。张鑫旭张老师每周都会有个小测帮助我们夯实基础，我从小测中学到很多，这篇文章是关于某次js小测的收获和思考：）。</p>\n<p>⭐️ps: 这篇文章更像是记录，把我零碎的知识串起来的文章，而不是说明原型链原理的文章。</p>\n</blockquote>\n<h1>问题引出的题目</h1>\n<p>实现一个方法，只要内容形态一致就认为数组和对象相等</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let obj1 = {a: [1, '2'], b: 2}\nlet obj2 = {b: 2, a: [1, '2']}\nlet arr1 = [1,2,{a: 1, b:2}, 9]\nlet arr2 = [1,2,{b: 2, a:1}, 9]\nequal(obj1, obj2) //return true\nequal(arr1, arr2) //return true\nequal(obj1, arr1) //return false\n\n// 然后我是这么写的（思路就是，递归+浅拷贝，大可跳过这部分，因为并不是我收获的重点😂）\nfunction equalObject(obj1, obj2) {\n    if (Object.keys(obj1).length != Object.keys(obj2).length) {\n        return false\n    } else {\n        Object.keys(obj1).forEach((key) => {\n            if (obj1[key] !== obj2[key]) {\n                return false\n            }\n        })\n        return true\n    }\n}\n\nfunction equalArray(arr1, arr2) {\n    return JSON.stringify(arr1) === JSON.stringify(arr2)\n}\n\nfunction equal(obj1, obj2) {\n    let typeEnum = {\n        'array': function (obj1, obj2) {\n            if (obj1.length !== obj2.length) {\n                return false\n            } else {\n                for (let i = 0; i &#x3C; obj1.length; i++) {\n                    let func = typeEnum[_detect(obj1[i], obj2[i])]\n                    if (!func(obj1[i], obj2[i])) {\n                        return false\n                    }\n                }\n                return true\n            }\n        },\n        'object': function (obj1, obj2) {\n            if (Object.keys(obj1).length != Object.keys(obj2).length) {\n                return false\n            } else {\n                let keys = Object.keys(obj1)\n                for (let k = 0; k &#x3C; keys.length; k++) {\n                    let key = keys[k]\n                    let func = typeEnum[_detect(obj1[key], obj2[key])]\n                    if (!func(obj1[key], obj2[key])) {\n                        return false\n                    }\n                }\n                return true\n            }\n        },\n        'other': function (obj1, obj2) {\n            return obj1 === obj2\n        }\n    }\n\n    function _detect(obj1, obj2) {\n        if (Array.isArray(obj1) &#x26;&#x26; Array.isArray(obj2)) {\n            return 'array'\n        } else if (typeof obj1 === 'object' &#x26;&#x26; typeof obj2 === 'object') {\n            return 'object'\n        } else {\n            return 'other'\n        }\n    }\n\n    let func = typeEnum[_detect(obj1, obj2)]\n    return func(obj1, obj2)\n}\n</code></pre>\n<p>但是张老师给刚开始帮我看的时候给了我另一个解决方式，思路差不多，但是代码十分精简</p>\n<pre><code class=\"language-js\">    if (!(o1 instanceof Object) || (o2 instanceof Object)) {\n        return false\n    }\n    if (Object.keys(o1).length !== Object.keys(o2).length) {\n        return false\n    }\n    return Object.keys(o1).every(v => {\n        if (o1[v] instanceof Object) {\n             return equal(o1[v], o2[v])\n        } else {\n            return o1[v]  === o2[v]\n        }\n    })\n}\n\n// 用Object.keys()直接处理了array和object两种类型的情况，虽然后来发现这种方法是是有点小问题的没办法处理equal（[1,2], {'0': 1, '1': 2})这种情况，但是我首先没想到那个（...因为基础不牢跑偏了orz），因为我首先想到的是为什么Object.keys（）可以用来同时处理array和object...\n</code></pre>\n<p>A：Object.keys() ,并不是Object.prototype上的方法，而是定义在Object函数上的静态方法</p>\n<h1>JS的原型系统  &#x26;  Object.keys</h1>\n<p>Q：为什么Object.keys（）可以用来同时处理array和object ？</p>\n<p>为了解决这个问题于是我对js的原型系统的相关概念的重新梳理了一下：</p>\n<p>（js基于原型的实现面向对象，注意区别对象，对象的原型，实例）</p>\n<p><img src=\"http://blog.minghuiyang1998.com/objectkeys-prototype_1.jpeg\" alt=\"objectkeys-prototype_1.pic\"></p>\n<h2>JS的原型系统</h2>\n<ul>\n<li>构造函数（串有关普通函数，构造函数，new，this）</li>\n<li>原型 （prototype属性）</li>\n<li>constructor</li>\n<li>__proto__指针</li>\n<li>原型链 （instance原型链的关系）</li>\n<li>静态方法（Object.keys().....)</li>\n</ul>\n<p>（ps：下述的大部分理解来自JStutorial<a href=\"https://javascript.info/\">https://javascript.info/</a>， 很多东西但当时看完题目也做对了觉得自己都懂了，然后遇到问题再重新理解才发现当时肯定是没懂😂）</p>\n<h4>1. 构造函数</h4>\n<ul>\n<li>\n<p>使用new调用普通函数则普通函数就成了构造函数 </p>\n</li>\n<li>\n<p>new关键词做了什么</p>\n<ol>\n<li>创建一个对象 let obj = { }</li>\n<li>obj.__proto__ = 构造函数.prototype</li>\n<li>执行构造函数中的代码</li>\n<li>返回这个对象</li>\n</ol>\n</li>\n<li>\n<p>用new调用构造函数的时候，调用函数的对象，即函数的this值指向的应该是新创建的对象即上面的obj</p>\n</li>\n</ul>\n<h4>2. prototype属性（原型）</h4>\n<p>​\t每个<strong>函数</strong>都有一个prototype属性，指向<strong>函数的原型对象</strong>(这个属性的值是一个对象)</p>\n<h4>3. constructor</h4>\n<p>​\t函数的原型对象都有一个constructor属性指向函数本身，用构造函数创建实例后，实例的__proto__（原型）和只会默认取得构造函数的prototype属性（解决了对象识别的问题，可以通过属性判断实例室友那个构造函数创建的）</p>\n<h4>4.__proto__指针</h4>\n<p>每个实例都有一个__proto__指针指向构造函数的原型对象</p>\n<h4>5.原型链</h4>\n<p>当试图访问实例的一个属性的时候，会沿着原性链层层向上搜索知道找到匹配的属性，否则报错</p>\n<h4>6.静态方法</h4>\n<p>（jstutorial当时讲这个的时候我真的以为我理解了🌚）</p>\n<p>重新补充上面概念的细节：</p>\n<h5>构造函数（这个地方在浏览器里面console.dir看看就会明白许多）</h5>\n<ul>\n<li>\n<p>所有的<strong>函数</strong>包括内置的<strong>Object()，Function()，Array()，还有自建函数function foo(){}</strong>是函数的__proto__都是一个匿名函数，与Object.prototype, Array.prototype…要区分开来</p>\n<ul>\n<li>special：这个<strong>匿名函数</strong>没有prototype属性,有一个constructor属性是Function（不是本身），<em>proto</em>指向Object.prototype</li>\n<li>special：<strong>函数Object（）</strong>的prototype属性指向Object.prototype, prototype包含两个属性constructor指向Object（）本身，<em>proto</em>指向null</li>\n</ul>\n</li>\n<li>其他<strong>函数如Function（），Array（）</strong>的prototype属性指向自己的原型对象，原型对象的constructor指向自己本身，原型对象的<em>proto</em>属性指向Object.prototype（即构造函数的原型对象是由Object生成的，但是看文章开始的图可见构造函数的__proto__(原型）是匿名函数，可见这两个东西是不一样，没有绑定关系的）</li>\n<li>prototype除了有constructor属性和_<strong>proto</strong>属性还有原型里面定义有的这个类型的方法，比如Array的concat，find等等方法</li>\n</ul>\n<h5>当使用class与extends构造对象的时候</h5>\n<ul>\n<li>使用extends关键词的函数的<em>proto</em>不会是匿名函数，是extends的那个Object(<strong>不仅仅是原型继承，原函数也继承</strong>)</li>\n</ul>\n<h2>Object.keys</h2>\n<p>但是打开看Array的__proto__发现并没有Object.keys()，因为这个方法是定义在Object对象上的方法）</p>\n<p><img src=\"http://blog.minghuiyang1998.com/objectkeys-prototype_2.jpeg\" alt=\"objectkeys-prototype_2.pic\"></p>\n<p>Array和Object都可以用来遍历元素是因为，Array可以看作是key是1，2，3..的Object，然后借用了定义在Object上的这个方法来将所有的key值放到了一个数组里返回</p>\n<h1>小结</h1>\n<p>​\t😂思路跑偏了好远，本来只是想知道为什么Object.keys（）可以用来同时处理array和object，不理解的原因归根究底就是没有理解静态方法，把原型链的知识又从头到尾梳理了一遍解决了很多之前含糊不清的点也是巨大的收获吧～：D</p>\n<p>ps：后来还想到了object移除一组值用的是delete key，array删除某个值用的是splice，为什么呢 ？某天再写吧，这太长了...</p>","frontmatter":{"path":"/develop/objectkeys-prototype"}},"next":{"html":"","frontmatter":{"path":"/develop/render"}}}}