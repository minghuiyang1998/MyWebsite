{"data":{"markdownRemark":{"html":"<blockquote>\n<p>这篇文章小结一下我理解的js是如何工作的？ 目的是把脑子里js引擎执行上下文，调用堆栈，eventloop，作用域作用域链，this的知识串起来（不会讨论service worker相关的内容），学习的时候往上并没有一篇十分完整的文章，所以花了一些时间才串了起来。</p>\n</blockquote>\n<p>简要的思路：</p>\n<ul>\n<li>程序执行方式</li>\n<li>v8引擎</li>\n<li>\n<p>js运行时</p>\n<ul>\n<li>宿主环境</li>\n<li>浏览器</li>\n<li>js运行时</li>\n<li>详细的代码段解析执行的过程</li>\n</ul>\n</li>\n</ul>\n<h1>程序的执行方式</h1>\n<ul>\n<li>解释：如Ruby， Javascript （转化一条执行一条，更灵活）</li>\n<li>编译：如C， C++， Java（全部转化完后执行，更多的优化）</li>\n</ul>\n<p>ps：现在很多语言两种方式都支持，即两种方式的区别是变为可执行机器码的过程有些不同</p>\n<p><strong>JS是解释型的还是编译型的？</strong></p>\n<p>​\t提出这个问题的原因是js存在声明提升，如果他是解释型的应该就不会有声明提升的问题呀。出现声明提升是有解释器的处理方式造成的。</p>\n<p>js的解释过程大致为：</p>\n<ul>\n<li>v8引擎进入作用域，词法分析整个作用域，形成AST，每遇到一个声明分配内存（这就造成了声明提升的现象，如果使用了babel应该就是在这个阶段就是改写生成的AST树变成ES5的语法）</li>\n<li>由AST再编为机器码，执行</li>\n</ul>\n<p>（ps：js的编译机制JIT（即时编译），会优化js代码的执行效率，优化类似于循环语句，还有进行热语句存储）</p>\n<p>​\t总的来说，js是单线程执行的，基于之前浏览器与操作系统那一篇，于chrome浏览器上就是每个tab上的渲染进程上的main线程。与java语言需要编译得到jar包不同的是，js是解释执行的，js引擎每次会解析执行部分代码（相当于是部分编译的）</p>\n<p><strong>JS与Java？</strong></p>\n<table>\n<thead>\n<tr>\n<th>java</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一次编译得到可执行文件（需要编译器和JVM）</td>\n<td>需要运行环境如NodeJS，浏览器（不需要编译器，但是需要宿主环境）</td>\n</tr>\n<tr>\n<td>强类型</td>\n<td>弱类型（动态类型）运行时才知道</td>\n</tr>\n<tr>\n<td>多线程（语言本身支持异步）</td>\n<td>单线程（环境支持异步）</td>\n</tr>\n</tbody>\n</table>\n<h1>v8引擎</h1>\n<ul>\n<li>v8引擎使用c++编写的，同时存在于浏览器和Node环境用于解释执行js代码</li>\n<li>v8旨在提高了js解析性能，使用了两个compiler</li>\n<li>\n<p>内部存在四个线程</p>\n<ul>\n<li>编译执行线程</li>\n<li>辅助编译线程</li>\n<li>检查耗时方法线程</li>\n<li>处理垃圾回收线程</li>\n</ul>\n</li>\n<li>\n<p>组成部分</p>\n<ul>\n<li>内存堆：内存分配 </li>\n<li>调用栈：代码执行</li>\n</ul>\n</li>\n</ul>\n<p>（ps：看过一篇文章讲了建立在理解js代码运行原理上写出优化的代码，写的超级好，分享在<a href=\"https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e\">这里</a>（需要科学上网））</p>\n<p>js是单线程执行的，所以也只有一个调用栈，所以js不存在死锁，但是会存在阻塞，那么如何在不阻塞UI的情况下执行复杂的代码和异步操作呢？</p>\n<p>[<a href=\"https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf\">参考文章</a>]</p>\n<h1>Js运行时</h1>\n<h2>宿主环境</h2>\n<p>​\t如浏览器， Node：Js引擎 + eventloop机制 + API（在浏览器和Node中的event loop机制是不一样的， 浏览器和Node提供的API也是不一样的）</p>\n<h2>浏览器</h2>\n<p>简要画了一下浏览器整个程序的运行过程</p>\n<p><img src=\"http://blog.minghuiyang1998.com/eventloop.png\" alt=\"eventloop\"></p>\n<h3>js运行时基本组成部分</h3>\n<p>浏览器提供webAPI   +    eventloop  +   call back queue</p>\n<ul>\n<li>\n<p>eventloop： js的执行机制用来调度js引擎执行js代码，也使js能实现异步执行。eventloop机制会调用js引擎处理程序中多个块的执行执行调度事件，监控调用栈与call back queue。</p>\n<blockquote>\n<p> 例如：js程序段发送ajax请求有回调，js引擎告诉宿主环境“嘿，我现在要暂停执行了，但你完成请求得到数据记得让我执行回调函数”然后浏览器设置网络响应的监听，当他有东西返回的时候它将会把回调函数插入到事件循环队列然后执行(<a href=\"\">隔得有点久了，找到参考原文会放上来</a>）</p>\n</blockquote>\n</li>\n<li>\n<p>Web API：访问其他的线程的接口，属于浏览器并行启动的其他部分（即在浏览器运行原理和操作系统中提到的其他进程与线程）</p>\n<p>如：DOM， ajax， setTimeout...</p>\n</li>\n<li>\n<p>call back queue：用来存放待执行的回调</p>\n</li>\n</ul>\n<p>例如：执行一个setTimeout(cb, time)</p>\n<ul>\n<li>首先加入call stack（调用栈）执行</li>\n<li>浏览器创建一个定时器（Web API的一部分）开始倒计时</li>\n<li>call stack执行完该代码弹出执行下一句</li>\n<li>定时完成将cb加入call back queue（回调队列）</li>\n<li>当call stack为空从call back queue中取出cs入call stack执行</li>\n</ul>\n<p>（所以setTimeout的定时是加入call back queue的事件而不是执行时间，setTimeout的主要任务也不是用来处理动画，而是拆分耗时操作，动画的操作应该尽可能使用requestAnimationFrame，因为它执行在线程重新渲染画面之前，而使用setTimeout就是每次执行call back queue队列中任务时，这里说的很粗略，推荐看看<a href=\"https://www.youtube.com/watch?v=cCOL7MC4Pl0\">JakeArchibald在Google大会上的演讲</a>理解一下（需要科学上网））</p>\n<p><strong>补充</strong></p>\n<ul>\n<li>\n<p>ES6指定了eventloop如何工作，即技术上应该是属于js引擎的范畴而不再是宿主环境的范畴，愿意是引入了promise</p>\n<ul>\n<li>\n<p>Job Queue（作业队列）</p>\n</li>\n<li>\n<p>eventloop 每执行到调用栈为空称为一个tick（一个eventloop，在Vue中也有$nextTick）</p>\n</li>\n<li>\n<p>作业队列实际跟在事件队列每个tick末尾的一个队列，在执行至call stack为空时，会先去检查job queue是否为空，将job queue执行为空才会去检查call back queue</p>\n</li>\n<li>\n<p>有点像setTimeout（cb，0）的hack，但有个更明确的执行顺序：稍后后执行但是会尽快执行</p>\n</li>\n</ul>\n<p>所以js中关于异步的操作就分为了两类</p>\n<ul>\n<li>setTimeout</li>\n<li>promise</li>\n</ul>\n</li>\n</ul>\n<p><strong>小结</strong>：在详述执行过程前重新理顺上文内容就是，js引擎解析执行js代码，有调用栈内存堆组成，只会在任一时刻执行一个程序，如何去调用js执行你的程序，由周围的宿主环境调度执行</p>\n<p>call stack有三个任务来源</p>\n<ul>\n<li>主任务队列（js文件中的代码，或script标签中的代码）</li>\n<li>Job queue（microtask）</li>\n<li>call back queue</li>\n</ul>\n<h3>js引擎处理一个代码段的详细过程</h3>\n<blockquote>\n<p> 这个过程解释了声明提升，作用域链及this的形成原因</p>\n</blockquote>\n<p>由于解析的方式会提到以下的语言特性</p>\n<ul>\n<li>闭包（closure）：在函数内部可以访问到外部函数（环境）变量的现象</li>\n<li>声明提升（raising）：用var声明在调用处下方的变量仍可访问</li>\n<li>this：调用函数的对象（ps：很多文章会解释为执行上下文，但是我认为不太对）</li>\n<li>作用域（scope）</li>\n<li>作用域链（scope chain）</li>\n</ul>\n<p>当js引擎读入一个代码段</p>\n<p><img src=\"http://blog.minghuiyang1998.com/scope-chain.png\" alt=\"scope-chain\"></p>\n<ul>\n<li>\n<p>这里的读入一个代码段常但不仅仅指的是一个函数的调用, 在ES6中是存在块级作用域的 </p>\n</li>\n<li>\n<p>js是静态作用域（lexical scope，还有一个dynamic scope这个概念在 <em>you don‘t know js</em> 有解释），含义是js的作用范围在编译时被确定，而不是运行时，这促成了js的两个语言特性闭包（closure）以及声明提升（raising）</p>\n</li>\n<li>\n<p>如果函数层层调用，call stack中会一层一层入栈，如果是递归不恰当，就会遇到栈溢出（stack exceeding）的情况。外层环境中的变量能否访问到和外层函数是否仍在call stack中是没有关系的，例如尾递归的调用方式虽然外层函数调用完成出栈了，但是由于保留在函数作用域中的是对变量的索引指向内存中变量存放的位置，所以即使是声明在外层函数中的变量，只要变量的引用不为0，就不会释放内存，所以closure的不恰当使用还会造成内存泄漏的问题（垃圾回收机制是不会回收这部分的内存的）</p>\n</li>\n<li>\n<p>如果是回调函数？为什么回调函数会有this丢失的情况？</p>\n<p>回调函数的声明并不会被分配内存和[[scope]]属性中，而是由web api进行处理，在异步任务结束时将函数的调用放入相应的队列。此时如果不绑定回调函数的调用对象this，那么函数就会遇到访问不到声明处外层对象内部定义的变量。这是由于在函数内部执行函数调用时，都隐式调用了function.call(this)，没有指定调用对象的函数调用，this指向window，那么遇到变量去作用域链上查找的时候window上没有就undefined了</p>\n</li>\n<li>\n<p>作用域链上的查找和原型链上的查找？</p>\n<p>当以objName.xxx方式调用函数时，当前对象的定义中没有该方法时就会到原型链上去查找，而在执行过程中遇到函数的调用，只会到作用域链上去查找</p>\n</li>\n<li>\n<p>可以像下图一样测试</p>\n<p>在控制台中查看call stack，然后在函数调用内部去把这个正在执行的函数console.dir()</p>\n<p><img src=\"http://blog.minghuiyang1998.com/call-stack.png\" alt=\"call stack\"></p>\n</li>\n</ul>\n<h1>总结</h1>\n<p>​\t我还在研究有些部分的正误，因为看到的资料大多对于执行上下文这个部分说的并不是很清楚，对这部分的一直挖掘其实是从很多文章误将this命名为执行上下文让我十分疑惑开始的，我也是慢慢理顺，现在得到的串联应该说是我能暂时能把所有知识接上的串联：）</p>","frontmatter":{"id":10025,"type":"develop","title":"js代码是如何被执行的","author":"jasmine","digest":"从渲染线程解析js代码到执行结束的理解整合","create_date":"Wed May 01 2019 12:58:13 GMT+0800 (CST)","update_date":"Wed May 01 2019 12:58:13 GMT+0800 (CST)","reading_time":"15 MIN READ","timestamp":1556686693495,"path":"/develop/js-eventloop-engine","image":"http://blog.minghuiyang1998.com/js-eventloop-engine.jpg","tags":["js works","eventloop","this","scope chain","context","call stack"],"palette":{"Vibrant":[169,107,78],"DarkVibrant":[4,35,45],"LightVibrant":[228,186,152],"Muted":[142,129,127],"DarkMuted":[102,60,59],"LightMuted":[207,188,175]}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"prev":{"html":"","frontmatter":{"path":"/develop/csrf-xss"}},"next":{"html":"<blockquote>\n<p>​\t开始做博客有段时间了，虽然进度很慢（学校作业很多）还是总结一下我思考的过程，希望以后别人问到我为什么这么选型，我还能给自己一个回答。这遍文章是围绕我blog选型展开的，但是会同时串一下自己对浏览器渲染方式的认识，还有对之前做的项目的一些选型的小理解，还是更像是记录而不是正统的分享文章叭。</p>\n<p>​\tblog 首先考虑到的就是良好的SEO，那么直接使用SPA类似于Vue全家桶和React就不太ok了，后面可能也会想要插入一些强交互的一些小想法的实现，那么为什么没选用Nuxt呢？但是在了解了Nuxt的渲染方式，又想熟悉一下react框架加上体验一下gatsby中的GraphQL，再加上其实可以通过跳转到另一个web服务来实现插入其他想法的方式，最终还是选择了静态网页生成Gatsby（这篇文章并不会详述我去熟悉这个新框架的过程，也许第二次总结blog开发的时候会写叭）</p>\n</blockquote>\n<h1>渲染方式选择基准</h1>\n<h2>性能</h2>\n<ul>\n<li>浏览器发出资源请求到接受到资源第一个字节的时间</li>\n<li>页面打开到页面主要内容可见的时间。</li>\n<li>页面打开到变得可以交互的时间。</li>\n</ul>\n<p>（ps：web performance API有很多关于从请求到返回渲染显示整个过程的信息，但是这篇文章感觉只会涉及到这三个）</p>\n<h2>SEO</h2>\n<p>​\t什么时候需要去考虑SEO呢？按照我的理解是如果网站本身就是需要登录强调客态的网站，那其实不用考虑，但对于一些网站首页，blog在选择在渲染方案，通常会考虑SEO。通常会选择服务器渲染来应对爬虫，这样爬虫拿到的首页html就是带有信息的而不是一个白屏，良好的SEO通常还会有更多的考虑比如语义化的标签，一些额外的信息等等，也会有一些网页禁止你去爬（比如利用robort.txt，微信公众号文章的内容就是不可爬的，SEO我并不是了解的特别深，了解了会再来补充！）</p>\n<h1>渲染方式</h1>\n<h3>SSR</h3>\n<ul>\n<li>rails，express，koa</li>\n</ul>\n<p>​\t服务器端渲染，我比较熟悉的是Express + ejs模版。虽然服务端框架加上模版渲染的方式已经跟当下比较流行的用框架 + webpack组装渲染页面， 服务端只提供数据的web app方式有一定差距了，但是还是有优点在的，比如天然的SEO，首屏速度。</p>\n<p>​\t值得一提的是我去实习的时候也使用过将Vue和React作为库引入使用，管理存在复杂状态管理的部分作为交互增强的开发方式。毕竟尤大大也说了“ 用 Vue 不代表你一定要做成 SPA。现在有些人提起 Vue 就好像一定要 CLI 全家桶，其实 Vue 从一开始就一直很注重对后端渲染的应用做渐进增强的用例，现在欧美也有很多的开发者拿 Vue 直接替代 jQuery 做常见的交互增强。对于真正适合做成 SPA 的应用，SEO 反而通常不是问题。你针对 marketing 的页面应该是静态分开部署的，app 本身则要登陆才能用，SEO 没有什么意义。少数既需要 SPA 强交互性，又对 SEO 和首屏速度有刚性需求的场景，这时候同构 SSR 就派上用场了。“<a href=\"https://www.zhihu.com/question/51949678/answer/146656850\">知乎</a></p>\n<h3>CSR</h3>\n<p>​\t客户端渲染。SPA应用如Vue，React，缺点是SEO（可以使用对应的框架和解决办法解决，但肯定需要额外的工作量跟ssr不同）和首屏速度（因为SPA的渲染方式比如Vue从取得index.html,  取得js到开始生命周期，最终挂载到节点显示出页面这段时间是肯定会存在的），优点是</p>\n<ul>\n<li>便于状态管理强交互，避免耗性能的DOM操作</li>\n<li>无缝切换，前端路由，单页应用</li>\n<li>良好的封装，优秀的开发速度</li>\n</ul>\n<h3>Prerendering（静态网页生成）</h3>\n<ul>\n<li>\n<p>在构建时生成静态HTML和页面的初始状态。比如Gatsby，Vuepress，Next.js的static export</p>\n</li>\n<li>\n<p>将页面中不会变化的内容直接渲染成出来，然后装到HTML中去。在浏览器端需要执行的js有限的假设下，该方法能够提高页面内容可见与可交互的速度。它能提供比服务器端渲染更快的速度，因为不需要生成HTML。还支持SPA，平台部署比如GitHub page，良好seo</p>\n</li>\n<li>\n<p>静态化渲染需要为每个URL生成单独的HTML，这是它的一个缺点。如果您无法提前预测这些URL的内容，或者或一个网站存在大量的URL，静态化渲染可能是不合适的。</p>\n</li>\n</ul>\n<h3>Rehydration（同构）</h3>\n<ul>\n<li>\n<p>比如Nuxt就是一个支持同构的框架。在服务器端渲染的dom树和数据的基础上，浏览器端利用JavaScript再次渲染。<code>asyncData</code>方法是在组件 <strong>初始化</strong> 前被调用的，所以在方法内是没有办法通过 <code>this</code> 来引用组件的实例对象。然后会合到data里面去</p>\n</li>\n</ul>\n<p>  <strong>Nuxt.js 的渲染流程</strong>（<a href=\"https://zhuanlan.zhihu.com/p/30393592\">参考</a>）</p>\n<p>  Nuxt.js 通过一系列构建于 Vue.js 之上的方法进行服务端渲染，具体流程如下:</p>\n<ol>\n<li>\n<p>调用 nuxtServerInit 方法当收到请求时，最先调用的即是 nuxtServerInit 方法，可以通过这个方法预先将服务器的数据保存，如已登录的用户信息等。另外，这个方法中也可以执行异步操作，并等待数据解析后返回。</p>\n</li>\n<li>\n<p>Middleware 层经过第一步后，请求会进入 Middleware 层，在该层中有三步操作：</p>\n</li>\n<li>\n<p>读取 nuxt.config.js 中全局 middleware 字段的配置，并调用相应的中间件方法</p>\n</li>\n<li>\n<p>匹配并加载与请求相对应的 layout</p>\n</li>\n<li>\n<p>调用 layout 和 page 的中间件方法</p>\n</li>\n<li>\n<p>调用 validate 方法在这一步可以对请求参数进行校验，或是对第一步中服务器下发的数据进行校验，如果校验失败，将抛出 404 页面。</p>\n</li>\n<li>\n<p>调用 fetch 及 asyncData 方法这两个方法都会在组件加载之前被调用，它们的职责各有不同，asyncData 用来异步的进行组件数据的初始化工作，而 fetch 方法偏重于异步获取数据后修改 Vuex 中的状态。</p>\n</li>\n<li>\n<p>在 Nuxt.js 的源码 util.js 中可以看到以下方法：</p>\n<pre><code class=\"language-js\">export function applyAsyncData (Component, asyncData = {}) {\n  const ComponentData = Component.options.data || noopData\n  Component.options.data = function () {\n    const data = ComponentData.call(this)\n    return { ...data, ...asyncData }\n  }\n  if (Component._Ctor &#x26;&#x26; Component._Ctor.options) {\n    Component._Ctor.options.data = Component.options.data\n  }\n}\n</code></pre>\n<p>这个方法会在 asyncData 方法调用完毕后进行调用，可以看到，组件从 asyncData 方法中获取的数据会和组件原生的 data 方法获取的数据做一次合并，最终仍然会在 data 方法中返回，所以得出，asyncData 方法其实是原生 data 方法的扩展。</p>\n<p>经过以上四步后，接下来就是渲染组件的工作了</p>\n</li>\n</ol>\n<p>  （在 .nuxt 目录下，你可以找到 server.js 文件，这个文件封装了 Nuxt.js 在服务端渲染的逻辑，包括一个完整的 Promise 对象的链式调用，从而完成上面描述的整个服务端渲染的步骤）</p>\n<ul>\n<li>页面导航导致跳转或刷新时，服务器会输出页面的HTML文档，并把该页面所需要的javascript和（用于渲染的）数据内联到文档一起输出。如果实现得当，这种方式可以像服务端渲染那样实现较快的首次内容绘制，之后客户端会通过一种叫rehydration的技术继续（在客户端）渲染</li>\n</ul>\n<ul>\n<li>\n<p>主要问题在于（<a href=\"https://developers.google.com/web/updates/2019/02/rendering-on-the-web\">参考</a>）：</p>\n<ul>\n<li>它会对可交互时间有明显的负面影响：尽管它缩短了首次绘制时间。服务端渲染的页面往往让人感觉已经加载完毕并可以开始交互了，但实际上只有等到客户端的js脚本执行并完成DOM事件绑定才能响应用户的交互（例如用户的输入行为）。在一些手机终端，这个过程会耗费几秒甚至几分钟的时间。也许你自己也经历过这样的场景：一个页面看起来已经加载完成了，但是在页面执行点击或者轻触的动作，结果却什么也没发生。这很快变得令人沮丧……“为什么(页面)没有反应？为什么我不能滚动？”</li>\n<li>Rehydration的问题不止于此，通常比因js导致的交互延迟更糟糕。为了让客户端js能够准确地渲染，而不用重新向服务器请求渲染所需的数据，目前服务端渲染通常会把UI所需的数据序列化并内联到HTML文档的script标签里。最终的HTML文档包含了更高层面的重复。从使用rehydration方案的一些真实网站搜集到的性能数据来看，该方案是极度不推荐的。究其原因，还是回到用户体验上：这种方式很容易让用户停留在“神秘的峡谷”之中，即界面可见但不可交互的状态</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>和传统ssr还是不一样的，没有绑定事件的，他是吧首屏先丢给客户端展示，然后再把剩下的js bundle下载绑定，所以能否在强行ssr的基础上，将bundle再细分为基础包和页面包，实现preload最小化业务js是提升性能的关键</li>\n</ul>\n<h1>小结 &#x26; Blog 的选型</h1>\n<p>​\t一个完美的解决方案通常服务端发送html跟最小的js来完成交互，基于上面的对几种方式的分析，没有解决方案是完美的，而是对需求的权衡。所以blog的选择Gatsby这个框架，不是因为它去年最热的静态页面生成框架，而是从几个方面SEO，良好的开发体验，文章内容的管理，用户看到页面的速度，尝试新技术几个方面综合考虑。我从入门前端使用过全家桶，传统的Express与模版渲染，静态网页生成，Nuxt慢慢能体会到从JQuery到Vue，React这些框架的意义，这对我来说无疑是在慢慢成长了～：D</p>","frontmatter":{"path":"/develop/browser-render-blog"}}}}