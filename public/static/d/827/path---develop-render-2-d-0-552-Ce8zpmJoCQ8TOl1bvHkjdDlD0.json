{"data":{"markdownRemark":{"html":"","frontmatter":{"id":10034,"type":"develop","title":"从输入url到显示页面","author":"jasmine","digest":"从输入url到显示出页面发生了什么，会涉及到浏览器的进程控制，缓存的查找，DNS解析，网络请求的过程，返回html浏览器的解析过程, js引擎对对代码解析执行过程（这个部分还有spa的解析过程的不同, 但这部分应该会放到web渲染方式的初步了解这一部分），这是很长的一系列知识点，是的我又来串知识点了：）","create_date":"Sat Apr 13 2019 09:36:35 GMT+0800 (CST)","update_date":"Sat Apr 13 2019 09:36:35 GMT+0800 (CST)","reading_time":"6 MIN READ","timestamp":1555119395000,"path":"/develop/render","image":"http://blog.minghuiyang1998.com/render.jpg","tags":["cache","browser"],"palette":{"Vibrant":[67,153,185],"DarkVibrant":[11,85,81],"LightVibrant":[157.6547619047619,202.90714285714282,219.74523809523808],"Muted":[55,101,109],"DarkMuted":[42,84,91],"LightMuted":[196,220,212]}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"prev":{"html":"<blockquote>\n<p>最近很着急的把脑子里的东西小结出来，因为最近学校事情比较多，写代码写的比较少。这篇文章同样从一道题出发，这道题来自于我今年参加的一次微信的笔试，但是写的不是太好还花了很多时间，反思了一下不是很难的题目，终归是基础不够好，还要多加学习。这篇文章就从题目出发，反思一下js的异步处理的一些方法。</p>\n</blockquote>\n<h1>题目</h1>\n<p>​\t大概是写一个测试函数，输入是总共执行的次数和每次发送的请求数目和请求url，比如输入3，4就是发送4个请求一共发送3次，然后记录每次请求到获得返回的时间，最后求平均值返回。</p>\n<h1>思考</h1>\n<ol>\n<li>\n<p>js的异步编程有几种解决方案？</p>\n<ul>\n<li>callback</li>\n<li>promise</li>\n<li>await/async</li>\n</ul>\n</li>\n<li>\n<p>这三种方式的区别</p>\n<ul>\n<li>错误捕获的方式</li>\n<li>常用的场景</li>\n</ul>\n</li>\n</ol>\n<p>​\t这道题存在一个串行异步和一个并行异步的，我当时直接就只考虑用promise写，因为日常开发没怎么用过async/await，但是用promise写就会写的很长，因为要处理串行异步就会存在一个递归。async/await虽然是promise的语法糖，但是学习一下就会发现对于题目这种用法async/await明显会更合适。</p>\n<p>​\t</p>\n<ol>\n<li>async/await 与 promise的关系？</li>\n</ol>\n<p>async/await 本质上还是promise，是promise和generator的语法糖（<a href=\"https://es6.ruanyifeng.com/#docs/async\">详情可见阮一峰老师的ES6入门</a>）</p>\n<pre><code class=\"language-js\">async function f3() {\n  /* 1. 这个函数里面的内容会被包成一个promise，\n  相当于在这里面写了一个return new Promise((resolve, reject) => {})，\n  然后这个Promise的里面又有一个Generator函数用于控制函数自动执行，\n  通过递归调用step函数，顺序执行每一行，如果是异步操作就等待resolve再执行下一行*/\n    \n  try {\n  /* 2. await 后面跟着一个promise, 而await下面的部分会被包成Promise.resolve()\n     相当于在这里写了一个 var z = Promise.resolve(data);  z.then((data)=>{\n      // 这里是await后面的代码\n     })\n  */\n    var z = await Promise.resolve(30);\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nf3();\n</code></pre>\n<p><strong>了解了这些以后我重写了一下这道题目的代码</strong> (这里省去了关于计算平均数的代码以便更清晰的展示思路)</p>\n<ol start=\"2\">\n<li>那么这道题用promise + 递归 写就会是下面这个样子（面试的时候我就是这样写的..)</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nfunction send(times, counts, url) {\n    return new Promise((resolve, reject)=>{\n        _sendConcurrentRequest(counts, url).then((data) => {\n            allData.push(data)\n            if (times) {\n                send(times - 1, counts, url) // 递归调用\n            } else {\n                // 计算平均数\n                resolve(avarage)\n            } \n        }).catch(e => reject(e))  \n    })\n}\n\nfunction _sendConcurrentRequest(counts, url) {\n    return new Promise((resolve, reject) => {\n        let tempList = [], _counts = counts\n         while (_counts) {\n            return new Promise((resolve, reject) => {\n                tempList.push(_sendRequest(url))\n                _counts --\n            })\n        }\n        Promise.all(tempList).then((data) => {\n            resolve(data)\n        }).catch(e => reject(e))\n    })\n}\n\n function _sendRequest(url) {\n    return new Promise((resolve, reject) => {\n      let start = Date.now()\n      // 模拟延时\n      setTimeout(() => {\n        let stop = Date.now()\n        resolve(stop - start)\n      }, 2000)\n    })\n  }\n</code></pre>\n<ol start=\"3\">\n<li>改为使用await + 递归</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nasync function send(times, counts, url) {\n    let data = await _sendConcurrentRequest(counts, url)\n    allData.push(data)\n    \n    if (times) {\n         await send(times - 1, counts, url)\n    } else {\n         return avarage\n    }\n}\n\n// 后面的两个函数没有变化仍是用Promise.all处理并行请求\n</code></pre>\n<ol start=\"4\">\n<li>将使用await的情况由递归变为循环，promise无法改写为循环的情况</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nasync function send(times, counts, url) {\n    while(times) {\n         let data = await _sendConcurrentRequest(counts, url)\n         allData.push(data)\n         times--\n    }\n    return avarage\n}\n</code></pre>\n<blockquote>\n<p>然后就会发现最后一种async/await+循环比第一种更便于理解语义清晰了无数倍：）</p>\n</blockquote>\n<h1>总结</h1>\n<p>​\t为了解决callback hell出现了promise，用then使异步任务的执行更清晰明了的。Promise 的存在问题是代码冗余，不管什么操作后任务都得用Promise 起来带上resolve，reject。例如两个串行的异步操作中间必须有一个同步操作，那么为了能够链式回调，中间的同步操作也得用promise包起来，然后才能then链式调用。而且新接入的同学为了把代码看懂需要去找到这个函数声明的地方，原来的语义就不那么直观了。后来​为了解决串行的异步出现async/await，真正使异步操作能够像同步代码一样去写。</p>\n<p>​\t每种方法都有自己的用处，不存在绝对的好与坏，实习之初导师建议我能用callback直接处理就用callback处理，类似于（返回数据处理不复杂的情况下）两个串联的请求也没必要用promise包起来，两个回调嵌套使用就好了，使用promise反而会使的语义很不清晰。</p>\n<p>​\t除此之使用异步编程最应该注意的问题就是为了后期能够快速定位错误，一定要注意异常捕获。</p>","frontmatter":{"path":"/develop/promise-await-async"}},"next":{"html":"<blockquote>\n<p>在前端快速发展的这段时间，越来越多的东西如app，桌面应用都可以用接近于前端的开发方式进行开发，这篇文章就是用来记录一下，看完了React的开发文档并使用过react后，结合之前使用过的vue，微信小程序的一些小想法。</p>\n</blockquote>\n<h1>SPA</h1>\n<h3>相似点</h3>\n<ul>\n<li>\n<p>数据驱动的（data变对应使用的地方会自动更新，适用于复杂的状态管理不再需要繁复的DOM操作）</p>\n<ul>\n<li>生命周期</li>\n<li>virtual dom和real dom 和diff 算法</li>\n<li>模版解析——实例化和内容替换涉及到一些写法不同的问题，都是由js渲染的页面</li>\n</ul>\n</li>\n<li>\n<p>组件化（组件也都是对象，无论是vue还是react）</p>\n<ul>\n<li>组件之间的消息传递：父子，子父，页面中的不相关的两个组件</li>\n<li>由基础组装高阶组件</li>\n</ul>\n</li>\n<li>\n<p>打包工具——webpack（避免用多组件的单文件显得很臃肿）</p>\n<ul>\n<li>由webpack完成组装，服务端只提供数据</li>\n</ul>\n</li>\n</ul>\n<h3>不同的体验</h3>\n<ul>\n<li>\n<p>首先写法上的不同是比较明显的，但我感觉都是模版的问题就不在这里纤细分析和列出来了</p>\n</li>\n<li>\n<p>vue有computed和watch和双向绑定v-model，而react需要手动引入mobX（这一点很类似于小程序的开发）</p>\n</li>\n<li>\n<p>react的编程体验更明显，会让我想起类似于于ejs的模版语言，在jsx模版里面可以嵌入任何的表达式，使用js的逻辑相较于vue更强的格式更快的上手比如v-if，v-else，react会更灵活但需要更好的js基础</p>\n</li>\n</ul>\n<h1>微信小程序</h1>\n<p>​\t小程序是没有computed和watched，也没有类似于vuex的多组件的状态管理工具（虽然大部分需求也不需要）。vue和react是前端框架，js运行是单线程的，而小程序是多线程的架构，每个页面一个webview线程再加上一个js线程，虽然分为三个文件js，html，css，但实际上是两个运行时wxs wxml wxss 在一个运行时类比于web的js html css，js是相当于一个控制器，与页面相关的操作要用setData和exec（）的方式，这样架构能够让页面更快加载渲染（具体可以看看小程序官网的生命周期），而之前看过一篇觉得挺好理解受益颇多的文章，了解<a href=\"https://mp.weixin.qq.com/s/X4yAFZBNLwaDUFYaR0Cn5g\">浏览器的加载原理</a>，一个tab的渲染在composite之前都是在渲染进程的main线程上进行的，即生成DOM和解析js是在一个线程上的，所以将script标签插入到其他节点中会阻塞html的解析DOM树的生成</p>\n<p>​\t由于实习的工作，在体验react之前更早接触小程序。最近面试也被问到过为什么做小程序的重构，从mpvue迁回原生，虽然小程序的写法和vue和react有相同之处，但我从上面的小的想法来看觉得是差别挺大的，所以可能vue的开发方式还是不能够完全照搬到小程序开发上来的吧。</p>\n<p>​</p>","frontmatter":{"path":"/develop/vue-react-wxminiapp"}}}}