{"componentChunkName":"component---src-templates-md-article-jsx","path":"/travel/New-Zealand-3","result":{"data":{"markdownRemark":{"html":"","frontmatter":{"id":10009,"type":"travel","title":"Days In New Zealand 3","author":"jasmine & jasmine-twin-sister","digest":"新西兰最后一篇，说完我们未完的南岛故事。","create_date":"Sun Apr 12 2019 11:23:40 GMT+0800 (CST)","update_date":"Sun Apr 12 2019 11:23:40 GMT+0800 (CST)","reading_time":"6 MIN READ","timestamp":1555039420000,"path":"/travel/New-Zealand-3","image":"http://blog.minghuiyang1998.com/nz_3.jpeg","tags":["New Zealand","travel","self-driving"],"palette":{"Vibrant":[92,132,180],"DarkVibrant":[37,54,83],"LightVibrant":[203,232,250],"Muted":[83,108,146],"DarkMuted":[53,75,107],"LightMuted":[162,182,208]}}}},"pageContext":{"prev":{"html":"<blockquote>\n<p> \t故事的开始是实习的导师问我认不认识echarts修改样式的customed.js文件开始的12行代码（tips：本文会出现大量代码用以描述我整理我所记录的js module的演化过程），笔记其实已经是很长时间之前的了，所以今天才来整理花了不少时间才看明白= =</p>\n</blockquote>\n<p>👇echarts修改样式的customed.js文件开始的12行代码：</p>\n<pre><code class=\"language-js\">(function(root, factory) {\n  if (typeof define === \"function\" &#x26;&#x26; define.amd) {\n    // AMD. Register as an anonymous module.\n    define([\"exports\", \"echarts\"], factory);\n  } else if (typeof exports === \"object\" &#x26;&#x26; typeof exports.nodeName !== \"string\") {\n    // CommonJS\n    factory(exports, require(\"echarts\"));\n  } else {\n    // Browser globals\n    factory({}, root.echarts);\n  }\n})(this, function(exports, echarts) {\n  var log = function(msg) {\n    if (typeof console !== \"undefined\") {\n      console &#x26;&#x26; console.error &#x26;&#x26; console.error(msg);\n    }\n  };\n  if (!echarts) {\n    log(\"ECharts is not Loaded\");\n    return;\n  }\n  echarts.registerTheme(\"customed\", {\n      // 这里删去了n行 \n  });\n});\n</code></pre>\n<p>​\t</p>\n<p>​\t在这段代码里面用到了UMD，js代码模块化的方式，使得这段代码既可以用于服务端又可以用于浏览器，同时也避免了污染全局变量。</p>\n<ul>\n<li>先判断是否支持AMD</li>\n<li>再判断是否支持CommonJs</li>\n<li>前两个都不存在公开到全局</li>\n</ul>\n<h1>在js代码里避免污染全局变量的方法</h1>\n<ul>\n<li>\n<p>闭包 + 立即执行</p>\n<pre><code class=\"language-js\">(function(){  \n    var page\n    function book(){\n      page = page + 1\n    }\n})()\n</code></pre>\n</li>\n<li>\n<p>命名空间（创建一个对象为他添加方法）调用函数或更改变量值，你总是需要通过主对象的名称将整个事物包装在匿名函数中并以这种方式保护范围</p>\n<pre><code class=\"language-js\">var main = {}\nmain.book = function(){}\nmain.page = 3;\n\nvar main = {\n  book:function(){},\n  \n}\n</code></pre>\n</li>\n<li>使用let，const（也是代码规范中的推荐做法）</li>\n<li>\n<p>模块化</p>\n<ul>\n<li>拆分大文件， 避免单文件内容过多过于臃肿</li>\n<li>便于支持组件化，单文件功能更独立，模块内外分离</li>\n<li>避免变量污染全局，解决命名冲突</li>\n</ul>\n</li>\n</ul>\n<h1>js模块化解决方案</h1>\n<p>​\t“历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。”  —— <a href=\"https://es6.ruanyifeng.com/#docs/module\">阮一峰ES6入门</a></p>\n<h3>js实现简单的同步异步模块化机制</h3>\n<ul>\n<li>同步</li>\n</ul>\n<pre><code></code></pre>\n<ul>\n<li>异步</li>\n</ul>\n<pre><code></code></pre>\n<h3>常见js模块化方案</h3>\n<ul>\n<li>\n<p>服务端</p>\n<ul>\n<li>nodejs使用CommonJS的解决方案（exports/require）实现模块加载（如果使用babel也可以使用import，export default的方式）</li>\n</ul>\n</li>\n<li>\n<p>客户端</p>\n<ul>\n<li>页面直出使用模版渲染 —— （将拆分出来的文件使用<script>或<link>标签的形式引入）</li>\n<li>客户端渲染SPA —— 使用webpack进行打包（使用import，export default）</li>\n</ul>\n<p>（使用webpack会只需要在解析完空白html后请求一次将打包好的bundle.js文件返回，而使用<script>与<link>则是每个标签都会进行请求）</p>\n</li>\n</ul>\n<h3>CommonJS AMD CMD UMD</h3>\n<ul>\n<li>commonJS (nodejs)：同步  用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</li>\n<li>AMD（异步）:所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。首先需要引入require.js文件和一个入口文件main.js。main.js中配置<code>require.config()</code>并规定项目中用到的基础模块。</li>\n<li>CMD和sea.js：CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。</li>\n<li>ES6 Module export{} import ：</li>\n</ul>\n<h3>webpack（现代前端模块打包工具）</h3>\n<p>​\t由于前端页面有着越来越重的交互需求，以Vue，React为代表的组件化的开发方式离不开模块打包工具</p>\n<p>以webpack为例：</p>\n<ul>\n<li>打包工具做了什么？</li>\n<li>为什么spa页面尤其需要打包工具？</li>\n<li>打包工具会带来什么问题？</li>\n<li>webpack与gulp？</li>\n</ul>","frontmatter":{"path":"/develop/module"}},"next":{"html":"<blockquote>\n<p>最近很着急的把脑子里的东西小结出来，因为最近学校事情比较多，写代码写的比较少。这篇文章同样从一道题出发，这道题来自于我今年参加的一次微信的笔试，但是写的不是太好还花了很多时间，反思了一下不是很难的题目，终归是基础不够好，还要多加学习。这篇文章就从题目出发，反思一下js的异步处理的一些方法。</p>\n</blockquote>\n<h1>题目</h1>\n<p>​\t大概是写一个测试函数，输入是总共执行的次数和每次发送的请求数目和请求url，比如输入3，4就是发送4个请求一共发送3次，然后记录每次请求到获得返回的时间，最后求平均值返回。</p>\n<h1>思考</h1>\n<ol>\n<li>\n<p>js的异步编程有几种解决方案？</p>\n<ul>\n<li>callback</li>\n<li>promise</li>\n<li>await/async</li>\n</ul>\n</li>\n<li>\n<p>这三种方式的区别</p>\n<ul>\n<li>错误捕获的方式</li>\n<li>常用的场景</li>\n</ul>\n</li>\n</ol>\n<p>​\t这道题存在一个串行异步和一个并行异步的，我当时直接就只考虑用promise写，因为日常开发没怎么用过async/await，但是用promise写就会写的很长，因为要处理串行异步就会存在一个递归。async/await虽然是promise的语法糖，但是学习一下就会发现对于题目这种用法async/await明显会更合适。</p>\n<p>​\t</p>\n<h1>实现</h1>\n<ol>\n<li>async/await 与 promise的关系？</li>\n</ol>\n<p>async/await 本质上还是promise，是promise和generator的语法糖（<a href=\"https://es6.ruanyifeng.com/#docs/async\">详情可见阮一峰老师的ES6入门</a>）</p>\n<pre><code class=\"language-js\">async function f3() {\n  /* 1. 这个函数里面的内容会被包成一个promise，\n  相当于在这里面写了一个return new Promise((resolve, reject) => {})，\n  然后这个Promise的里面又有一个Generator函数用于控制函数自动执行，\n  通过递归调用step函数，顺序执行每一行，如果是异步操作就等待resolve再执行下一行*/\n    \n  try {\n  /* 2. await 后面跟着一个promise, 而await下面的部分会被包成Promise.resolve()\n     相当于在这里写了一个 var z = Promise.resolve(data);  z.then((data)=>{\n      // 这里是await后面的代码\n     })\n  */\n    var z = await Promise.resolve(30);\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nf3();\n</code></pre>\n<p><strong>了解了这些以后我重写了一下这道题目的代码</strong> (这里省去了关于计算平均数的代码以便更清晰的展示思路)</p>\n<ol start=\"2\">\n<li>那么这道题用promise + 递归 写就会是下面这个样子（面试的时候我就是这样写的..)</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nfunction send(times, counts, url) {\n    return new Promise((resolve, reject)=>{\n        _sendConcurrentRequest(counts, url).then((data) => {\n            allData.push(data)\n            if (times) {\n                send(times - 1, counts, url) // 递归调用\n            } else {\n                // 计算平均数\n                resolve(avarage)\n            } \n        }).catch(e => reject(e))  \n    })\n}\n\nfunction _sendConcurrentRequest(counts, url) {\n    return new Promise((resolve, reject) => {\n        let tempList = [], _counts = counts\n         while (_counts) {\n            return new Promise((resolve, reject) => {\n                tempList.push(_sendRequest(url))\n                _counts --\n            })\n        }\n        Promise.all(tempList).then((data) => {\n            resolve(data)\n        }).catch(e => reject(e))\n    })\n}\n\n function _sendRequest(url) {\n    return new Promise((resolve, reject) => {\n      let start = Date.now()\n      // 模拟延时\n      setTimeout(() => {\n        let stop = Date.now()\n        resolve(stop - start)\n      }, 2000)\n    })\n  }\n</code></pre>\n<ol start=\"3\">\n<li>改为使用await + 递归</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nasync function send(times, counts, url) {\n    let data = await _sendConcurrentRequest(counts, url)\n    allData.push(data)\n    \n    if (times) {\n         await send(times - 1, counts, url)\n    } else {\n         return avarage\n    }\n}\n\n// 后面的两个函数没有变化仍是用Promise.all处理并行请求\n</code></pre>\n<ol start=\"4\">\n<li>将使用await的情况由递归变为循环，promise无法改写为循环的情况</li>\n</ol>\n<pre><code class=\"language-js\">let allData = []\nasync function send(times, counts, url) {\n    while(times) {\n         let data = await _sendConcurrentRequest(counts, url)\n         allData.push(data)\n         times--\n    }\n    return avarage\n}\n</code></pre>\n<blockquote>\n<p>然后就会发现最后一种async/await+循环比第一种更便于理解语义清晰了无数倍：）</p>\n</blockquote>\n<h1>总结</h1>\n<p>​\t为了解决callback hell出现了promise，用then使异步任务的执行更清晰明了的。Promise 的存在问题是代码冗余，不管什么操作后任务都得用Promise 起来带上resolve，reject。例如两个串行的异步操作中间必须有一个同步操作，那么为了能够链式回调，中间的同步操作也得用promise包起来，然后才能then链式调用。而且新接入的同学为了把代码看懂需要去找到这个函数声明的地方，原来的语义就不那么直观了。后来​为了解决串行的异步出现async/await，真正使异步操作能够像同步代码一样去写。</p>\n<p>​\t每种方法都有自己的用处，不存在绝对的好与坏，实习之初导师建议我能用callback直接处理就用callback处理，类似于（返回数据处理不复杂的情况下）两个串联的请求也没必要用promise包起来，两个回调嵌套使用就好了，使用promise反而会使的语义很不清晰。</p>\n<p>​\tcallback和promise是解决异步的两种方案，async/await只是promise的语法糖，用promise都可以解决，但是由于异步操作也会出现串行，并行，循环异步的情景，通过这道题我觉得循环串行异步的场景中用async/await实现会比较清晰，其他的情况下promise也够用了。能不同步的两个或多个异步操作就尽量别同步会阻塞，除此之使用异步编程最应该注意的问题就是为了后期能够快速定位错误，一定要注意异常捕获。</p>","frontmatter":{"path":"/develop/promise-await-async"}}}},"staticQueryHashes":[]}