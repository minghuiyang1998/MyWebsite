{"componentChunkName":"component---src-templates-md-article-jsx","path":"/develop/browser-render-blog","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>​\t开始做博客有段时间了，虽然进度很慢（学校作业很多）还是总结一下我思考的过程，希望以后别人问到我为什么这么选型，我还能给自己一个回答。这遍文章是围绕我blog选型展开的，但是会同时串一下自己对浏览器渲染方式的认识，还有对之前做的项目的一些选型的小理解，还是更像是记录而不是正统的分享文章叭。</p>\n<p>​\tblog 首先考虑到的就是良好的SEO，那么直接使用SPA类似于Vue全家桶和React就不太ok了，后面可能也会想要插入一些强交互的一些小想法的实现，那么为什么没选用Nuxt呢？但是在了解了Nuxt的渲染方式，又想熟悉一下react框架加上体验一下gatsby中的GraphQL，再加上其实可以通过跳转到另一个web服务来实现插入其他想法的方式，最终还是选择了静态网页生成Gatsby（这篇文章并不会详述我去熟悉这个新框架的过程，也许第二次总结blog开发的时候会写叭）</p>\n</blockquote>\n<h1>渲染方式选择基准</h1>\n<h2>性能</h2>\n<ul>\n<li>浏览器发出资源请求到接受到资源第一个字节的时间</li>\n<li>页面打开到页面主要内容可见的时间。</li>\n<li>页面打开到变得可以交互的时间。</li>\n</ul>\n<p>（ps：web performance API有很多关于从请求到返回渲染显示整个过程的信息，但是这篇文章感觉只会涉及到这三个）</p>\n<h2>SEO</h2>\n<p>​\t什么时候需要去考虑SEO呢？按照我的理解是如果网站本身就是需要登录强调客态的网站，那其实不用考虑，但对于一些网站首页，blog在选择在渲染方案，通常会考虑SEO。通常会选择服务器渲染来应对爬虫，这样爬虫拿到的首页html就是带有信息的而不是一个白屏，良好的SEO通常还会有更多的考虑比如语义化的标签，一些额外的信息等等，也会有一些网页禁止你去爬（比如利用robort.txt，微信公众号文章的内容就是不可爬的，SEO我并不是了解的特别深，了解了会再来补充！）</p>\n<h1>渲染方式</h1>\n<h3>SSR</h3>\n<ul>\n<li>rails，express，koa</li>\n</ul>\n<p>​\t服务器端渲染，我比较熟悉的是Express + ejs模版。虽然服务端框架加上模版渲染的方式已经跟当下比较流行的用框架 + webpack组装渲染页面， 服务端只提供数据的web app方式有一定差距了，但是还是有优点在的，比如天然的SEO，首屏速度。</p>\n<p>​\t值得一提的是我去实习的时候也使用过将Vue和React作为库引入使用，管理存在复杂状态管理的部分作为交互增强的开发方式。毕竟尤大大也说了“ 用 Vue 不代表你一定要做成 SPA。现在有些人提起 Vue 就好像一定要 CLI 全家桶，其实 Vue 从一开始就一直很注重对后端渲染的应用做渐进增强的用例，现在欧美也有很多的开发者拿 Vue 直接替代 jQuery 做常见的交互增强。对于真正适合做成 SPA 的应用，SEO 反而通常不是问题。你针对 marketing 的页面应该是静态分开部署的，app 本身则要登陆才能用，SEO 没有什么意义。少数既需要 SPA 强交互性，又对 SEO 和首屏速度有刚性需求的场景，这时候同构 SSR 就派上用场了。“<a href=\"https://www.zhihu.com/question/51949678/answer/146656850\">知乎</a></p>\n<h3>CSR</h3>\n<p>​\t客户端渲染。SPA应用如Vue，React，缺点是SEO（可以使用对应的框架和解决办法解决，但肯定需要额外的工作量跟ssr不同）和首屏速度（因为SPA的渲染方式比如Vue从取得index.html,  取得js到开始生命周期，最终挂载到节点显示出页面这段时间是肯定会存在的），优点是</p>\n<ul>\n<li>便于状态管理强交互，避免耗性能的DOM操作</li>\n<li>无缝切换，前端路由，单页应用</li>\n<li>良好的封装，优秀的开发速度</li>\n</ul>\n<h3>Prerendering（静态网页生成）</h3>\n<ul>\n<li>在构建时生成静态HTML和页面的初始状态。比如Gatsby，Vuepress，Next.js的static export</li>\n<li>将页面中不会变化的内容直接渲染成出来，然后装到HTML中去。在浏览器端需要执行的js有限的假设下，该方法能够提高页面内容可见与可交互的速度。它能提供比服务器端渲染更快的速度，因为不需要生成HTML。还支持SPA，平台部署比如GitHub page，良好seo</li>\n<li>静态化渲染需要为每个URL生成单独的HTML，这是它的一个缺点。如果您无法提前预测这些URL的内容，或者或一个网站存在大量的URL，静态化渲染可能是不合适的。</li>\n</ul>\n<h3>Rehydration（同构）</h3>\n<ul>\n<li>\n<p>比如Nuxt就是一个支持同构的框架。在服务器端渲染的dom树和数据的基础上，浏览器端利用JavaScript再次渲染。<code>asyncData</code>方法是在组件 <strong>初始化</strong> 前被调用的，所以在方法内是没有办法通过 <code>this</code> 来引用组件的实例对象。然后会合到data里面去</p>\n<p><strong>Nuxt.js 的渲染流程</strong>（<a href=\"https://zhuanlan.zhihu.com/p/30393592\">参考</a>）</p>\n<p>Nuxt.js 通过一系列构建于 Vue.js 之上的方法进行服务端渲染，具体流程如下:</p>\n<ol>\n<li>调用 nuxtServerInit 方法当收到请求时，最先调用的即是 nuxtServerInit 方法，可以通过这个方法预先将服务器的数据保存，如已登录的用户信息等。另外，这个方法中也可以执行异步操作，并等待数据解析后返回。</li>\n<li>Middleware 层经过第一步后，请求会进入 Middleware 层，在该层中有三步操作：</li>\n<li>读取 nuxt.config.js 中全局 middleware 字段的配置，并调用相应的中间件方法</li>\n<li>匹配并加载与请求相对应的 layout</li>\n<li>调用 layout 和 page 的中间件方法</li>\n<li>调用 validate 方法在这一步可以对请求参数进行校验，或是对第一步中服务器下发的数据进行校验，如果校验失败，将抛出 404 页面。</li>\n<li>调用 fetch 及 asyncData 方法这两个方法都会在组件加载之前被调用，它们的职责各有不同，asyncData 用来异步的进行组件数据的初始化工作，而 fetch 方法偏重于异步获取数据后修改 Vuex 中的状态。</li>\n<li>在 Nuxt.js 的源码 util.js 中可以看到以下方法：</li>\n</ol>\n<pre><code class=\"language-js\">export function applyAsyncData (Component, asyncData = {}) {\n  const ComponentData = Component.options.data || noopData\n  Component.options.data = function () {\n    const data = ComponentData.call(this)\n    return { ...data, ...asyncData }\n  }\n  if (Component._Ctor &#x26;&#x26; Component._Ctor.options) {\n    Component._Ctor.options.data = Component.options.data\n  }\n}\n</code></pre>\n<p>这个方法会在 asyncData 方法调用完毕后进行调用，可以看到，组件从 asyncData 方法中获取的数据会和组件原生的 data 方法获取的数据做一次合并，最终仍然会在 data 方法中返回，所以得出，asyncData 方法其实是原生 data 方法的扩展。</p>\n<p>经过以上四步后，接下来就是渲染组件的工作了</p>\n<p>（在 .nuxt 目录下，你可以找到 server.js 文件，这个文件封装了 Nuxt.js 在服务端渲染的逻辑，包括一个完整的 Promise 对象的链式调用，从而完成上面描述的整个服务端渲染的步骤）</p>\n</li>\n<li>页面导航导致跳转或刷新时，服务器会输出页面的HTML文档，并把该页面所需要的javascript和（用于渲染的）数据内联到文档一起输出。如果实现得当，这种方式可以像服务端渲染那样实现较快的首次内容绘制，之后客户端会通过一种叫rehydration的技术继续（在客户端）渲染</li>\n<li>\n<p>主要问题在于（<a href=\"https://developers.google.com/web/updates/2019/02/rendering-on-the-web\">参考</a>）：</p>\n<ul>\n<li>它会对可交互时间有明显的负面影响：尽管它缩短了首次绘制时间。服务端渲染的页面往往让人感觉已经加载完毕并可以开始交互了，但实际上只有等到客户端的js脚本执行并完成DOM事件绑定才能响应用户的交互（例如用户的输入行为）。在一些手机终端，这个过程会耗费几秒甚至几分钟的时间。也许你自己也经历过这样的场景：一个页面看起来已经加载完成了，但是在页面执行点击或者轻触的动作，结果却什么也没发生。这很快变得令人沮丧……“为什么(页面)没有反应？为什么我不能滚动？”</li>\n<li>Rehydration的问题不止于此，通常比因js导致的交互延迟更糟糕。为了让客户端js能够准确地渲染，而不用重新向服务器请求渲染所需的数据，目前服务端渲染通常会把UI所需的数据序列化并内联到HTML文档的script标签里。最终的HTML文档包含了更高层面的重复。从使用rehydration方案的一些真实网站搜集到的性能数据来看，该方案是极度不推荐的。究其原因，还是回到用户体验上：这种方式很容易让用户停留在“神秘的峡谷”之中，即界面可见但不可交互的状态</li>\n</ul>\n</li>\n<li>和传统ssr还是不一样的，没有绑定事件的，他是吧首屏先丢给客户端展示，然后再把剩下的js bundle下载绑定，所以能否在强行ssr的基础上，将bundle再细分为基础包和页面包，实现preload最小化业务js是提升性能的关键</li>\n</ul>\n<h1>小结 &#x26; Blog 的选型</h1>\n<p>​\t一个完美的解决方案通常服务端发送html跟最小的js来完成交互，基于上面的对几种方式的分析，没有解决方案是完美的，而是对需求的权衡。所以blog的选择Gatsby这个框架，不是因为它去年最热的静态页面生成框架，而是从几个方面SEO，良好的开发体验，文章内容的管理，用户看到页面的速度，尝试新技术几个方面综合考虑。我从入门前端使用过全家桶，传统的Express与模版渲染，静态网页生成，Nuxt慢慢能体会到从JQuery到Vue，React这些框架的意义，这对我来说无疑是在慢慢成长了～：D</p>\n<blockquote>\n<p>Gatsby 是把静态渲染好的html输出，里面并没有绑定js那么也会存在可见但不可交互的情况</p>\n<p>但是静态渲染和同构还是有区别的，一个是在服务端还要请求数据绑定一次，而静态则是直接返回静态页面会更快</p>\n</blockquote>","frontmatter":{"id":10003,"type":"develop","title":"web渲染方式与我的blog选型","author":"jasmine","digest":"当我想要开始做一个blog的时候，我想了些什么...","create_date":"Fri Apr 17 2019 14:29:07 GMT+0800 (CST)","update_date":"Fri Apr 17 2019 14:29:07 GMT+0800 (CST)","reading_time":"3 MIN READ","timestamp":1555482547000,"path":"/develop/browser-render-blog","image":"http://blog.minghuiyang1998.com/browser-render-blog.jpg","tags":["render","blog"],"palette":{"Vibrant":[130,166,212],"DarkVibrant":[33.9392857142857,62.353571428571406,98.6607142857143],"LightVibrant":[195,219,252],"Muted":[100,124,159],"DarkMuted":[41,65,77],"LightMuted":[188,196,220]}}}},"pageContext":{"prev":{"html":"<blockquote>\n<p>写在前面：最近慢慢在把实习期间积累的笔记，整理输出。张鑫旭张老师每周都会有个小测帮助我们夯实基础，我从小测中学到很多，这篇文章是关于某次js小测的收获和思考：）。</p>\n<p>⭐️ps: 这篇文章更像是记录，把我零碎的知识串起来的文章，而不是说明原型链原理的文章。</p>\n</blockquote>\n<h1>问题引出的题目</h1>\n<p>实现一个方法，只要内容形态一致就认为数组和对象相等</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let obj1 = {a: [1, '2'], b: 2}\nlet obj2 = {b: 2, a: [1, '2']}\nlet arr1 = [1,2,{a: 1, b:2}, 9]\nlet arr2 = [1,2,{b: 2, a:1}, 9]\nequal(obj1, obj2) //return true\nequal(arr1, arr2) //return true\nequal(obj1, arr1) //return false\n\n// 然后我是这么写的（思路就是，递归+浅拷贝，大可跳过这部分，因为并不是我收获的重点😂）\nfunction equalObject(obj1, obj2) {\n    if (Object.keys(obj1).length != Object.keys(obj2).length) {\n        return false\n    } else {\n        Object.keys(obj1).forEach((key) => {\n            if (obj1[key] !== obj2[key]) {\n                return false\n            }\n        })\n        return true\n    }\n}\n\nfunction equalArray(arr1, arr2) {\n    return JSON.stringify(arr1) === JSON.stringify(arr2)\n}\n\nfunction equal(obj1, obj2) {\n    let typeEnum = {\n        'array': function (obj1, obj2) {\n            if (obj1.length !== obj2.length) {\n                return false\n            } else {\n                for (let i = 0; i &#x3C; obj1.length; i++) {\n                    let func = typeEnum[_detect(obj1[i], obj2[i])]\n                    if (!func(obj1[i], obj2[i])) {\n                        return false\n                    }\n                }\n                return true\n            }\n        },\n        'object': function (obj1, obj2) {\n            if (Object.keys(obj1).length != Object.keys(obj2).length) {\n                return false\n            } else {\n                let keys = Object.keys(obj1)\n                for (let k = 0; k &#x3C; keys.length; k++) {\n                    let key = keys[k]\n                    let func = typeEnum[_detect(obj1[key], obj2[key])]\n                    if (!func(obj1[key], obj2[key])) {\n                        return false\n                    }\n                }\n                return true\n            }\n        },\n        'other': function (obj1, obj2) {\n            return obj1 === obj2\n        }\n    }\n\n    function _detect(obj1, obj2) {\n        if (Array.isArray(obj1) &#x26;&#x26; Array.isArray(obj2)) {\n            return 'array'\n        } else if (typeof obj1 === 'object' &#x26;&#x26; typeof obj2 === 'object') {\n            return 'object'\n        } else {\n            return 'other'\n        }\n    }\n\n    let func = typeEnum[_detect(obj1, obj2)]\n    return func(obj1, obj2)\n}\n</code></pre>\n<p>但是张老师给刚开始帮我看的时候给了我另一个解决方式，思路差不多，但是代码十分精简</p>\n<pre><code class=\"language-js\">    if (!(o1 instanceof Object) || (o2 instanceof Object)) {\n        return false\n    }\n    if (Object.keys(o1).length !== Object.keys(o2).length) {\n        return false\n    }\n    return Object.keys(o1).every(v => {\n        if (o1[v] instanceof Object) {\n             return equal(o1[v], o2[v])\n        } else {\n            return o1[v]  === o2[v]\n        }\n    })\n}\n\n// 用Object.keys()直接处理了array和object两种类型的情况，虽然后来发现这种方法是是有点小问题的没办法处理equal（[1,2], {'0': 1, '1': 2})这种情况，但是我首先没想到那个（...因为基础不牢跑偏了orz），因为我首先想到的是为什么Object.keys（）可以用来同时处理array和object...\n</code></pre>\n<p>A：Object.keys() ,并不是Object.prototype上的方法，而是定义在Object函数上的静态方法</p>\n<h1>JS的原型系统  &#x26;  Object.keys</h1>\n<p>Q：为什么Object.keys（）可以用来同时处理array和object ？</p>\n<p>为了解决这个问题于是我对js的原型系统的相关概念的重新梳理了一下：</p>\n<p>（js基于原型的实现面向对象，注意区别对象，对象的原型，实例）</p>\n<p><img src=\"http://blog.minghuiyang1998.com/objectkeys-prototype_1.jpeg\" alt=\"objectkeys-prototype_1.pic\"></p>\n<h2>JS的原型系统</h2>\n<ul>\n<li>构造函数（串有关普通函数，构造函数，new，this）</li>\n<li>原型 （prototype属性）</li>\n<li>constructor</li>\n<li>__proto__指针</li>\n<li>原型链 （instance原型链的关系）</li>\n<li>静态方法（Object.keys().....)</li>\n</ul>\n<p>（ps：下述的大部分理解来自JStutorial<a href=\"https://javascript.info/\">https://javascript.info/</a>， 很多东西但当时看完题目也做对了觉得自己都懂了，然后遇到问题再重新理解才发现当时肯定是没懂😂）</p>\n<h4>1. 构造函数</h4>\n<ul>\n<li>使用new调用普通函数则普通函数就成了构造函数 </li>\n<li>\n<p>new关键词做了什么</p>\n<ol>\n<li>创建一个对象 let obj = { }</li>\n<li>obj.__proto__ = 构造函数.prototype</li>\n<li>执行构造函数中的代码</li>\n<li>返回这个对象</li>\n</ol>\n</li>\n<li>用new调用构造函数的时候，调用函数的对象，即函数的this值指向的应该是新创建的对象即上面的obj</li>\n</ul>\n<h4>2. prototype属性（原型）</h4>\n<p>​\t每个<strong>函数</strong>都有一个prototype属性，指向<strong>函数的原型对象</strong>(这个属性的值是一个对象)</p>\n<h4>3. constructor</h4>\n<p>​\t函数的原型对象都有一个constructor属性指向函数本身，用构造函数创建实例后，实例的__proto__（原型）和只会默认取得构造函数的prototype属性（解决了对象识别的问题，可以通过属性判断实例室友那个构造函数创建的）</p>\n<h4>4.__proto__指针</h4>\n<p>每个实例都有一个__proto__指针指向构造函数的原型对象</p>\n<h4>5.原型链</h4>\n<p>当试图访问实例的一个属性的时候，会沿着原性链层层向上搜索知道找到匹配的属性，否则报错</p>\n<h4>6.静态方法</h4>\n<p>（jstutorial当时讲这个的时候我真的以为我理解了🌚）</p>\n<p>重新补充上面概念的细节：</p>\n<h5>构造函数（这个地方在浏览器里面console.dir看看就会明白许多）</h5>\n<ul>\n<li>\n<p>所有的<strong>函数</strong>包括内置的<strong>Object()，Function()，Array()，还有自建函数function foo(){}</strong>是函数的__proto__都是一个匿名函数，与Object.prototype, Array.prototype…要区分开来</p>\n<ul>\n<li>special：这个<strong>匿名函数</strong>没有prototype属性,有一个constructor属性是Function（不是本身），<em>proto</em>指向Object.prototype</li>\n<li>special：<strong>函数Object（）</strong>的prototype属性指向Object.prototype, prototype包含两个属性constructor指向Object（）本身，<em>proto</em>指向null</li>\n</ul>\n</li>\n<li>其他<strong>函数如Function（），Array（）</strong>的prototype属性指向自己的原型对象，原型对象的constructor指向自己本身，原型对象的<em>proto</em>属性指向Object.prototype（即构造函数的原型对象是由Object生成的，但是看文章开始的图可见构造函数的__proto__(原型）是匿名函数，可见这两个东西是不一样，没有绑定关系的）</li>\n<li>prototype除了有constructor属性和_<strong>proto</strong>属性还有原型里面定义有的这个类型的方法，比如Array的concat，find等等方法</li>\n</ul>\n<h5>当使用class与extends构造对象的时候</h5>\n<ul>\n<li>使用extends关键词的函数的<em>proto</em>不会是匿名函数，是extends的那个Object(<strong>不仅仅是原型继承，原函数也继承</strong>)</li>\n</ul>\n<h2>Object.keys</h2>\n<p>但是打开看Array的__proto__发现并没有Object.keys()，因为这个方法是定义在Object对象上的方法）</p>\n<p><img src=\"http://blog.minghuiyang1998.com/objectkeys-prototype_2.jpeg\" alt=\"objectkeys-prototype_2.pic\"></p>\n<p>Array和Object都可以用来遍历元素是因为，Array可以看作是key是1，2，3..的Object，然后借用了定义在Object上的这个方法来将所有的key值放到了一个数组里返回</p>\n<h1>小结</h1>\n<p>​\t😂思路跑偏了好远，本来只是想知道为什么Object.keys（）可以用来同时处理array和object，不理解的原因归根究底就是没有理解静态方法，把原型链的知识又从头到尾梳理了一遍解决了很多之前含糊不清的点也是巨大的收获吧～：D</p>\n<p>ps：后来还想到了object移除一组值用的是delete key，array删除某个值用的是splice，为什么呢 ？某天再写吧，这太长了...</p>","frontmatter":{"path":"/develop/objectkeys-prototype"}},"next":{"html":"","frontmatter":{"path":"/develop/render"}}}},"staticQueryHashes":[]}